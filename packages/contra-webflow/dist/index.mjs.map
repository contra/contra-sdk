{"version":3,"sources":["../src/runtime.ts"],"names":["ATTR_PREFIX","ATTRS","RuntimeState","programId","updates","state","pageNumber","experts","oldestPage","loading","ContraWebflowRuntime","config","ContraClient","allContainers","containers","container","error","selector","baseProgramId","expertListElement","containerIndex","containerId","timeout","element","paginationMode","limit","filterControls","control","filterKey","filterType","eventListener","debouncedReload","eventType","button","action","target","e","isPageNavigation","response","offset","currentPage","totalPages","hasNextPage","hasPreviousPage","isLoadMore","allExperts","filters","totalCount","targetGrid","template","card","expert","expertCard","fieldName","format","value","displayValue","utils","rating","fullStars","hasHalfStar","emptyStars","starsHtml","i","textElement","url","mediaType","parent","mediaElement","urlLower","isVideo","ext","isCloudinaryVideo","originalElement","video","posterUrl","fallbackImg","img","placeholder","videoUrl","from","to","attr","existingStyle","repeatType","maxItems","tag","items","item","itemElement","showWhen","hideWhen","shouldShow","condition","parts","field","expertValue","result","expectedValue","emptyElement","pageSize","activeFilters","_key","key","_target","currentOffset","nextOffset","prevOffset","lastPageOffset","errorText","loadMoreButtons","btnElement","prevButtons","nextButtons","firstButtons","lastButtons","paginationSections","section","loadedCount","indicator","newExperts","fragment","name","v","option","type","newFilters","processedValue","currentArray","event","show","loadingElement","errorElement","eventName","detail","message","args","autoInit","configElement","runtime"],"mappings":"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","file":"index.mjs","sourcesContent":["import { ContraClient, utils } from '@contra/client';\nimport type {\n  ExpertProfile,\n  ExpertFilters,\n  FilterChangeEvent,\n  ExpertLoadEvent,\n  ErrorEvent,\n  ExpertField\n} from '@contra/types';\n\n/**\n * Webflow Runtime for Contra Experts\n * Features: Performance optimization, filtering, error handling, loading states\n */\n\n// Configuration interface\ninterface RuntimeConfig {\n  apiKey: string;\n  program?: string;  // Program ID from config\n  debug?: boolean;\n  loadingClass?: string;\n  errorClass?: string;\n  emptyClass?: string;\n  autoReload?: boolean;\n  debounceDelay?: number;\n  maxRetries?: number;\n  \n  // Pagination Configuration\n  paginationMode?: 'traditional' | 'infinite' | 'hybrid';\n  infiniteScrollThreshold?: number;        // Pixels from bottom to trigger load\n  preloadNextPage?: boolean;              // Preload next page for performance\n  maxCachedPages?: number;                // Max pages to keep in memory\n  smoothScrollBehavior?: 'auto' | 'smooth';\n  loadMoreText?: string;                  // Custom \"Load More\" button text\n  \n  // Video configuration\n  videoAutoplay?: boolean;\n  videoHoverPlay?: boolean;\n  videoMuted?: boolean;\n  videoLoop?: boolean;\n  videoControls?: boolean;\n}\n\n// Attribute constants\nconst ATTR_PREFIX = 'data-contra-';\nconst ATTRS = {\n  // Core attributes\n  program: 'program',\n  template: 'template',\n  loading: 'loading',\n  error: 'error',\n  empty: 'empty',\n  \n  // Field binding\n  field: 'field',\n  format: 'format',\n  \n  // Repeating elements\n  repeat: 'repeat',\n  max: 'max',\n  \n  // Filter controls\n  filter: 'filter',\n  filterType: 'filter-type',\n  \n  // Filter attributes\n  available: 'available',\n  \n  // Sorting and pagination\n  sort: 'sort',\n  page: 'page',\n  limit: 'limit',\n  \n  // Pagination mode and controls\n  paginationMode: 'pagination-mode',\n  infiniteLoading: 'infinite-loading',\n  paginationInfo: 'pagination-info',\n  \n  // UI states\n  showWhen: 'show-when',\n  hideWhen: 'hide-when',\n  \n  // Actions\n  action: 'action',\n  target: 'target'\n} as const;\n\n// State management\nclass RuntimeState {\n  private states = new Map<string, {\n    filters: ExpertFilters;\n    experts: ExpertProfile[];\n    loading: boolean;\n    error: Error | null;\n    currentPage: number;\n    totalCount: number;\n    // Advanced pagination state\n    cachedPages: Map<number, ExpertProfile[]>;\n    loadingPages: Set<number>;\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n    isInfiniteLoading: boolean;\n    lastScrollPosition: number;\n    paginationMode: 'traditional' | 'infinite' | 'hybrid';\n    programId: string;\n  }>();\n\n  getState(programId: string) {\n    if (!this.states.has(programId)) {\n      this.states.set(programId, {\n        filters: {},\n        experts: [],\n        loading: false,\n        error: null,\n        currentPage: 1,\n        totalCount: 0,\n        // Advanced pagination defaults\n        cachedPages: new Map(),\n        loadingPages: new Set(),\n        hasNextPage: false,\n        hasPreviousPage: false,\n        isInfiniteLoading: false,\n        lastScrollPosition: 0,\n        paginationMode: 'traditional',\n        programId: ''\n      });\n    }\n    return this.states.get(programId)!;\n  }\n\n  updateState(programId: string, updates: Partial<ReturnType<RuntimeState['getState']>>) {\n    const state = this.getState(programId);\n    Object.assign(state, updates);\n    this.states.set(programId, state);\n  }\n\n  // Advanced pagination helpers\n  cachePage(programId: string, pageNumber: number, experts: ExpertProfile[]) {\n    const state = this.getState(programId);\n    state.cachedPages.set(pageNumber, experts);\n    \n    // Implement LRU cache cleanup\n    if (state.cachedPages.size > 5) { // maxCachedPages from config\n      const oldestPage = Math.min(...state.cachedPages.keys());\n      state.cachedPages.delete(oldestPage);\n    }\n  }\n\n  getCachedPage(programId: string, pageNumber: number): ExpertProfile[] | null {\n    const state = this.getState(programId);\n    return state.cachedPages.get(pageNumber) || null;\n  }\n\n  setPageLoading(programId: string, pageNumber: number, loading: boolean) {\n    const state = this.getState(programId);\n    if (loading) {\n      state.loadingPages.add(pageNumber);\n    } else {\n      state.loadingPages.delete(pageNumber);\n    }\n  }\n\n  isPageLoading(programId: string, pageNumber: number): boolean {\n    const state = this.getState(programId);\n    return state.loadingPages.has(pageNumber);\n  }\n}\n\n/**\n * Main Runtime Class\n */\nexport class ContraWebflowRuntime {\n  private client: ContraClient;\n  private config: Required<RuntimeConfig>;\n  private state = new RuntimeState();\n  private debouncedReload: Map<string, () => void> = new Map();\n\n  constructor(config: RuntimeConfig) {\n    this.config = {\n      debug: false,\n      program: '',  // Default empty program\n      loadingClass: 'loading',\n      errorClass: 'error',\n      emptyClass: 'empty',\n      autoReload: true,\n      debounceDelay: 300,\n      maxRetries: 3,\n      // Pagination Configuration defaults\n      paginationMode: 'traditional',\n      infiniteScrollThreshold: 500,\n      preloadNextPage: true,\n      maxCachedPages: 5,\n      smoothScrollBehavior: 'auto',\n      loadMoreText: 'Load More',\n      // Video configuration defaults\n      videoAutoplay: false,      // No autoplay by default (better UX)\n      videoHoverPlay: true,       // Hover to play by default\n      videoMuted: true,           // Muted for autoplay compatibility\n      videoLoop: true,            // Loop videos\n      videoControls: false,       // No controls for cleaner look\n      ...config\n    };\n\n    this.client = new ContraClient({\n      apiKey: this.config.apiKey,\n      debug: this.config.debug\n    });\n\n    this.log('Runtime initialized', this.config);\n  }\n\n  /**\n   * Initialize the runtime and find all expert containers\n   */\n  async init(): Promise<void> {\n    this.log('Initializing runtime...');\n\n    try {\n      // Find all expert containers\n      const allContainers = this.findExpertContainers();\n      // Filter out already initialized containers\n      const containers = allContainers.filter(container => \n        !container.hasAttribute('data-contra-initialized')\n      );\n      \n      this.log(`Found ${containers.length} uninitialised expert containers (${allContainers.length} total)`);\n\n      // Initialize each container\n      for (const container of containers) {\n        await this.initContainer(container);\n      }\n\n      this.log('Runtime initialization complete');\n    } catch (error) {\n      this.log('Runtime initialization failed', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Find the specific element within the container that holds the expert list and configuration.\n   */\n  private findExpertListElement(container: Element): Element | null {\n    // This element is defined by having pagination or limit attributes.\n    const selector = `[${ATTR_PREFIX}${ATTRS.limit}], [${ATTR_PREFIX}${ATTRS.paginationMode}]`;\n    return this.querySelector(container, selector);\n  }\n\n  /**\n   * Initialize a single expert container\n   */\n  private async initContainer(container: Element): Promise<void> {\n    // Get program ID from config\n    const baseProgramId = this.config.program;\n    if (!baseProgramId) {\n      this.log('No program ID found in config', container);\n      return;\n    }\n\n    // Find the specific list element within the container\n    const expertListElement = this.findExpertListElement(container);\n    if (!expertListElement) {\n      this.log('No expert list element found in container', container);\n      return;\n    }\n\n    // Create a simple, unique ID for this container instance for state management.\n    const allContainers = Array.from(document.querySelectorAll('.grid-section'));\n    const containerIndex = allContainers.indexOf(container);\n    const containerId = `container-${containerIndex}`;\n\n    this.log(`Initializing container #${containerIndex} (ID: ${containerId}) for program: ${baseProgramId}`);\n\n    try {\n      // Setup container state from the list element\n      this.setupContainer(container, expertListElement, containerId, baseProgramId);\n      \n      // Wire up filter controls (scoped to the whole container)\n      this.wireFilterControls(container, containerId);\n      \n      // Wire up action buttons (scoped to the whole container)\n      this.wireActionButtons(container, containerId);\n      \n      // Setup debounced reload for this container\n      this.setupDebouncedReload(containerId);\n      \n      // Load initial data\n      await this.loadExperts(container, containerId);\n\n    } catch (error) {\n      this.log(`Failed to initialize container ${containerId}`, error);\n      this.showError(container, error as Error);\n    }\n  }\n\n  /**\n   * Setup debounced reload for a container\n   */\n  private setupDebouncedReload(containerId: string): void {\n    let timeout: NodeJS.Timeout;\n    this.debouncedReload.set(containerId, () => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        const container = document.querySelector(`[data-container-id=\"${containerId}\"]`);\n        if (container) {\n          this.loadExperts(container as Element, containerId);\n        }\n      }, this.config.debounceDelay);\n    });\n  }\n\n  /**\n   * Setup container with initial state and classes\n   */\n  private setupContainer(container: Element, expertListElement: Element, containerId: string, programId: string): void {\n    const element = container as HTMLElement;\n    \n    // Add runtime classes and identifier\n    element.classList.add('contra-runtime');\n    element.setAttribute('data-contra-initialized', 'true');\n    element.setAttribute('data-container-id', containerId); // Use simple ID for DOM selection\n    \n    // Parse pagination mode and settings from the list element\n    const paginationMode = this.getAttr(expertListElement, ATTRS.paginationMode) || 'traditional';\n    const limit = parseInt(this.getAttr(expertListElement, ATTRS.limit) || '20');\n    \n    // Initialize container state using the simple containerId\n    this.state.updateState(containerId, { \n      filters: { limit, offset: 0 },\n      paginationMode: paginationMode as 'traditional' | 'infinite',\n      experts: [],\n      loading: false,\n      error: null,\n      currentPage: 1,\n      totalCount: 0,\n      hasNextPage: false,\n      hasPreviousPage: false,\n      cachedPages: new Map(),\n      loadingPages: new Set(),\n      isInfiniteLoading: false,\n      lastScrollPosition: 0,\n      programId: programId // This is the base programId for API calls\n    });\n    \n    this.log(`Container ${containerId} setup complete:`, { paginationMode, limit, programId });\n  }\n\n  /**\n   * Wire up filter controls to auto-update\n   */\n  private wireFilterControls(container: Element, containerId: string): void {\n    const filterControls = this.querySelectorAll(container, `[${ATTR_PREFIX}${ATTRS.filter}]`);\n    \n    this.log(`Found ${filterControls.length} filter controls for container: ${containerId}`);\n\n    filterControls.forEach(control => {\n      const filterKey = this.getAttr(control, ATTRS.filter);\n      const filterType = this.getAttr(control, ATTRS.filterType) || 'replace';\n      \n      if (!filterKey) return;\n\n      const eventListener = () => {\n        this.updateFilter(containerId, filterKey, this.getControlValue(control as HTMLInputElement | HTMLSelectElement), filterType);\n        if (this.config.autoReload) {\n          const debouncedReload = this.debouncedReload.get(containerId);\n          if (debouncedReload) {\n            debouncedReload();\n          }\n        }\n      };\n\n      // Add event listeners based on control type\n      if (control instanceof HTMLInputElement) {\n        const eventType = ['range', 'number', 'text', 'search'].includes(control.type) ? 'input' : 'change';\n        control.addEventListener(eventType, eventListener);\n      } else if (control instanceof HTMLSelectElement) {\n        control.addEventListener('change', eventListener);\n      }\n      \n      this.log(`Wired filter control for ${containerId}: ${filterKey} (${filterType})`, control);\n    });\n  }\n\n  /**\n   * Wire up action buttons (pagination, sorting, etc.)\n   */\n  private wireActionButtons(container: Element, containerId: string): void {\n    const actionButtons = this.querySelectorAll(container, `[${ATTR_PREFIX}${ATTRS.action}]`);\n    \n    actionButtons.forEach(button => {\n      const action = this.getAttr(button, ATTRS.action);\n      const target = this.getAttr(button, ATTRS.target);\n      \n      if (!action) return;\n\n      button.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.handleAction(containerId, action, target, button);\n      });\n    });\n  }\n\n  /**\n   * Load experts for a container with proper pagination handling\n   */\n  private async loadExperts(container: Element, containerId: string, isPageNavigation = false): Promise<void> {\n    const state = this.state.getState(containerId);\n    const programId = state.programId;\n    \n    this.log(`Loading experts for container: ${containerId}, program: ${programId}`, state.filters);\n\n    try {\n      // Show loading state\n      this.showLoading(container, true);\n      this.state.updateState(containerId, { loading: true, error: null });\n\n      // Fetch experts from API\n      const response = await this.client.listExperts(programId, state.filters);\n      \n      this.log(`Loaded ${response.data.length} experts`, response);\n\n      // Update pagination state based on mode\n      if (state.paginationMode === 'traditional') {\n        this.handleTraditionalPaginationResponse(containerId, container, response);\n      } else {\n        this.handleInfinitePaginationResponse(containerId, container, response);\n      }\n\n    } catch (error) {\n      this.log(`Failed to load experts for container: ${containerId}`, error);\n      \n      this.state.updateState(containerId, { \n        loading: false, \n        error: error as Error \n      });\n      \n      this.showError(container, error as Error);\n      \n      // Dispatch error event\n      this.dispatchEvent(container, 'expertsError', {\n        error: error as Error,\n        context: `Loading experts for container ${containerId}`\n      } as ErrorEvent);\n    } finally {\n      this.showLoading(container, false);\n    }\n  }\n\n  /**\n   * Handle traditional pagination response (page-based navigation)\n   */\n  private handleTraditionalPaginationResponse(\n    containerId: string, \n    container: Element, \n    response: { data: ExpertProfile[], totalCount: number }\n  ): void {\n    const state = this.state.getState(containerId);\n    \n    // Calculate pagination metadata\n    const limit = state.filters.limit || 20;\n    const offset = state.filters.offset || 0;\n    const currentPage = Math.floor(offset / limit) + 1;\n    const totalPages = Math.ceil(response.totalCount / limit);\n    const hasNextPage = currentPage < totalPages;\n    const hasPreviousPage = currentPage > 1;\n\n    // Update state\n    this.state.updateState(containerId, {\n      experts: response.data,\n      totalCount: response.totalCount,\n      currentPage: currentPage,\n      hasNextPage: hasNextPage,\n      hasPreviousPage: hasPreviousPage,\n      loading: false\n    });\n\n    // Cache the page\n    this.state.cachePage(containerId, currentPage, response.data);\n\n    // Render experts (replace mode for traditional pagination)\n    this.renderExperts(container, response.data);\n    \n    // Update UI\n    this.updateUIStates(container, containerId);\n    this.updatePaginationControls(container, containerId);\n    \n    // Dispatch event\n    this.dispatchEvent(container, 'expertsLoaded', {\n      experts: response.data,\n      totalCount: response.totalCount,\n      filters: state.filters,\n      page: currentPage,\n      totalPages: totalPages,\n      hasNextPage: hasNextPage,\n      hasPreviousPage: hasPreviousPage,\n      paginationMode: 'traditional'\n    } as ExpertLoadEvent);\n\n    this.log(`Traditional pagination: Page ${currentPage}/${totalPages}, ${response.data.length} experts loaded`);\n  }\n\n  /**\n   * Handle infinite pagination response (cumulative loading)\n   */\n  private handleInfinitePaginationResponse(\n    containerId: string, \n    container: Element, \n    response: { data: ExpertProfile[], totalCount: number }\n  ): void {\n    const state = this.state.getState(containerId);\n    const isLoadMore = state.experts.length > 0;\n    \n    // For infinite loading, append to existing experts\n    const allExperts = isLoadMore ? [...state.experts, ...response.data] : response.data;\n    const hasNextPage = allExperts.length < response.totalCount;\n    \n    // Update state\n    this.state.updateState(containerId, {\n      experts: allExperts,\n      totalCount: response.totalCount,\n      hasNextPage: hasNextPage,\n      hasPreviousPage: false, // Not applicable for infinite scroll\n      loading: false,\n      isInfiniteLoading: false\n    });\n\n    // Render experts (append mode for infinite loading)\n    if (isLoadMore) {\n      this.renderNewExperts(container, response.data);\n    } else {\n      this.renderExperts(container, response.data);\n    }\n    \n    // Update UI\n    this.updateUIStates(container, containerId);\n    this.updatePaginationControls(container, containerId);\n    \n    // Dispatch event\n    this.dispatchEvent(container, 'expertsLoaded', {\n      experts: response.data,\n      totalExperts: allExperts,\n      totalCount: response.totalCount,\n      filters: state.filters,\n      hasNextPage: hasNextPage,\n      isLoadMore: isLoadMore,\n      paginationMode: 'infinite'\n    } as ExpertLoadEvent);\n\n    this.log(`Infinite pagination: ${allExperts.length}/${response.totalCount} experts loaded`);\n  }\n\n  /**\n   * Calculate current page from filters\n   */\n  private calculateCurrentPage(filters: ExpertFilters): number {\n    const limit = filters.limit || 20;\n    const offset = filters.offset || 0;\n    return Math.floor(offset / limit) + 1;\n  }\n\n  /**\n   * Update pagination state consistently\n   */\n  private updatePaginationState(\n    programId: string, \n    experts: ExpertProfile[], \n    totalCount: number, \n    filters: ExpertFilters\n  ): void {\n    const limit = filters.limit || 20;\n    const offset = filters.offset || 0;\n    const currentPage = Math.floor(offset / limit) + 1;\n    const totalPages = Math.ceil(totalCount / limit);\n    \n    this.state.updateState(programId, {\n      experts: experts,\n      totalCount: totalCount,\n      currentPage: currentPage,\n      hasNextPage: currentPage < totalPages,\n      hasPreviousPage: currentPage > 1,\n      loading: false\n    });\n  }\n\n  /**\n   * Render experts into the container\n   */\n  private renderExperts(container: Element, experts: ExpertProfile[]): void {\n    // --- Self-Healing Rendering Sandbox ---\n    // 1. Ensure a dedicated grid for experts exists.\n    let targetGrid = this.querySelector(container, '.expert-grid');\n    if (!targetGrid) {\n      this.log('NOTICE: .expert-grid not found. Creating it dynamically for safe rendering.');\n      targetGrid = document.createElement('div');\n      targetGrid.className = 'expert-grid';\n      container.appendChild(targetGrid);\n    }\n\n    // 2. Find the template, wherever it is in the container.\n    const template = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.template}]`);\n    if (!template) {\n      this.log('CRITICAL: Template element not found inside container. Cannot render experts.', container);\n      this.showError(container, new Error(\"Runtime Error: A template element with 'data-contra-template' is required inside your component.\"));\n      return;\n    }\n    \n    // 3. Ensure the template is inside the grid to protect it from being cleared.\n    if (template.parentElement !== targetGrid) {\n      targetGrid.appendChild(template);\n    }\n\n    // 4. Perform surgical, non-destructive rendering ONLY within the grid.\n    const existingCards = this.querySelectorAll(targetGrid, '.expert-card:not([data-contra-template])');\n    existingCards.forEach(card => card.remove());\n\n    experts.forEach(expert => {\n      const expertCard = this.populateExpertCard(template, expert);\n      targetGrid.appendChild(expertCard);\n    });\n\n    this.log(`Rendered ${experts.length} expert cards into the safe grid`, targetGrid);\n  }\n\n  /**\n   * Populate expert card from template\n   */\n  private populateExpertCard(template: Element, expert: ExpertProfile): Element {\n    const card = template.cloneNode(true) as Element;\n    \n    // Remove template attribute and show the card\n    card.removeAttribute(`${ATTR_PREFIX}${ATTRS.template}`);\n    (card as HTMLElement).style.display = '';\n\n    // Populate field bindings\n    this.populateFields(card, expert);\n    \n    // Handle repeating elements (projects, social links)\n    this.populateRepeatingElements(card, expert);\n    \n    // Handle conditional display\n    this.handleConditionalDisplay(card, expert);\n\n    return card;\n  }\n\n  /**\n   * Populate data fields in the card\n   */\n  private populateFields(card: Element, expert: ExpertProfile): void {\n    const fieldElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.field}]`);\n    \n    fieldElements.forEach(element => {\n      const fieldName = this.getAttr(element, ATTRS.field) as ExpertField;\n      const format = this.getAttr(element, ATTRS.format);\n      \n      if (!fieldName || !(fieldName in expert)) return;\n\n      const value = expert[fieldName];\n      this.setElementValue(element, value, format);\n    });\n\n    // Handle star ratings\n    const starsElements = this.querySelectorAll(card, '[data-contra-stars]');\n    starsElements.forEach(element => {\n      if (expert.averageReviewScore) {\n        this.renderStarRating(element, expert.averageReviewScore);\n      }\n    });\n  }\n\n  /**\n   * Set element value with proper formatting\n   */\n  private setElementValue(element: Element, value: any, format?: string | null): void {\n    if (value == null || value === '') return;\n\n    // Media type detection and handling\n    if (this.isMediaField(element) && typeof value === 'string' && value.trim()) {\n      this.setMediaValue(element, value);\n      return;\n    }\n\n    if (element instanceof HTMLAnchorElement) {\n      element.href = String(value);\n      if (!element.textContent?.trim()) {\n        element.textContent = String(value);\n      }\n    } else if (element instanceof HTMLInputElement) {\n      element.value = String(value);\n    } else if (element instanceof HTMLImageElement) {\n      // Regular image handling for avatars and other images\n      element.src = String(value);\n      element.alt = element.alt || 'Image';\n    } else {\n      // Text content with formatting\n      let displayValue = String(value);\n      \n      if (format) {\n        switch (format) {\n          case 'currency':\n            displayValue = typeof value === 'number' ? `$${value}` : displayValue;\n            break;\n          case 'rate':\n            displayValue = utils.formatRate(typeof value === 'number' ? value : null);\n            break;\n          case 'rating':\n            // Format rating to one decimal place (5.0, 4.9, etc.)\n            displayValue = typeof value === 'number' ? value.toFixed(1) : displayValue;\n            break;\n          case 'earnings':\n            // Format earnings like $25k+\n            if (typeof value === 'number') {\n              if (value >= 1000000) {\n                displayValue = `$${Math.floor(value / 1000000)}M+`;\n              } else if (value >= 1000) {\n                displayValue = `$${Math.floor(value / 1000)}k+`;\n              } else {\n                displayValue = `$${value}`;\n              }\n            }\n            break;\n          case 'number':\n            displayValue = typeof value === 'number' ? value.toLocaleString() : displayValue;\n            break;\n          case 'truncate':\n            displayValue = displayValue.length > 100 ? displayValue.substring(0, 97) + '...' : displayValue;\n            break;\n          case 'boolean':\n            displayValue = value ? 'Yes' : 'No';\n            break;\n          case 'availability':\n            displayValue = value ? 'Available' : 'Not Available';\n            break;\n        }\n      }\n      \n      element.textContent = displayValue;\n    }\n  }\n\n  /**\n   * Star rating rendering with optional text display\n   */\n  private renderStarRating(element: Element, rating: number): void {\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = rating % 1 >= 0.5;\n    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);\n    \n    let starsHtml = '';\n    \n    // Full stars\n    for (let i = 0; i < fullStars; i++) {\n      starsHtml += '<span class=\"contra-star contra-star-full\"></span>';\n    }\n    \n    // Half star\n    if (hasHalfStar) {\n      starsHtml += '<span class=\"contra-star contra-star-half\"></span>';\n    }\n    \n    // Empty stars\n    for (let i = 0; i < emptyStars; i++) {\n      starsHtml += '<span class=\"contra-star contra-star-empty\"></span>';\n    }\n    \n    element.innerHTML = starsHtml;\n    \n    // Also update any rating text elements in the same card\n    const card = element.closest('[data-contra-template]') || element.closest('.expert-card');\n    if (card) {\n      const ratingTextElements = this.querySelectorAll(card, '[data-contra-rating-text]');\n      ratingTextElements.forEach(textElement => {\n        textElement.textContent = rating.toFixed(1);\n      });\n    }\n  }\n\n  /**\n   * Media type detection and element handling\n   */\n  private isMediaField(element: Element): boolean {\n    const field = this.getAttr(element, ATTRS.field);\n    // Only apply advanced media handling to project cover URLs, not avatars\n    return field === 'coverUrl';\n  }\n\n  /**\n   * Media value setting with automatic type detection\n   */\n  private setMediaValue(element: Element, url: string): void {\n    const mediaType = this.detectMediaType(url);\n    const parent = element.parentElement;\n    \n    if (!parent) {\n      this.log('Media element has no parent for replacement', element);\n      return;\n    }\n\n    // Remove existing media element\n    element.remove();\n\n    // Create appropriate media element\n    let mediaElement: HTMLElement;\n    \n    switch (mediaType) {\n      case 'video':\n        mediaElement = this.createVideoElement(url, element);\n        break;\n      case 'image':\n      default:\n        mediaElement = this.createImageElement(url, element);\n        break;\n    }\n\n    // Preserve classes and attributes from original element\n    this.transferAttributes(element, mediaElement);\n    \n    // Insert new media element\n    parent.appendChild(mediaElement);\n    \n    this.log(`Created ${mediaType} element for URL: ${url}`);\n  }\n\n  /**\n   * Detect media type from URL\n   */\n  private detectMediaType(url: string): 'image' | 'video' {\n    if (!url || typeof url !== 'string') {\n      this.log('Invalid URL provided to detectMediaType:', url);\n      return 'image';\n    }\n    \n    const urlLower = url.toLowerCase();\n    \n    // Video formats\n    const videoExtensions = ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.ogg'];\n    const isVideo = videoExtensions.some(ext => urlLower.includes(ext));\n    \n    // Special handling for Cloudinary video URLs\n    const isCloudinaryVideo = urlLower.includes('cloudinary.com/') && urlLower.includes('/video/');\n    \n    return (isVideo || isCloudinaryVideo) ? 'video' : 'image';\n  }\n\n  /**\n   * Create video element with fallback\n   */\n  private createVideoElement(url: string, originalElement: Element): HTMLVideoElement {\n    const video = document.createElement('video');\n    \n    // Video attributes\n    video.src = url;\n    video.muted = this.config.videoMuted;\n    video.loop = this.config.videoLoop;\n    video.playsInline = true;\n    video.preload = 'metadata';\n    video.controls = this.config.videoControls;\n    \n    // Maintain aspect ratio and object-fit from original\n    video.style.width = '100%';\n    video.style.height = '100%';\n    video.style.objectFit = 'cover';\n    video.style.borderRadius = 'inherit';\n    \n    // Autoplay configuration\n    if (this.config.videoAutoplay) {\n      video.autoplay = true;\n      video.setAttribute('autoplay', '');\n    }\n    \n    // Error handling with fallback to poster or placeholder\n    video.onerror = () => {\n      this.log(`Video failed to load: ${url}`);\n      // Try to extract a thumbnail from Cloudinary video URL\n      const posterUrl = this.extractVideoThumbnail(url);\n      if (posterUrl) {\n        const fallbackImg = this.createImageElement(posterUrl, originalElement);\n        video.parentElement?.replaceChild(fallbackImg, video);\n      } else {\n        // Show placeholder\n        video.style.background = '#f3f4f6';\n        video.style.position = 'relative';\n        video.innerHTML = '<div style=\"position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#9ca3af;font-size:12px;\">Video unavailable</div>';\n      }\n    };\n\n    // Hover-to-play functionality (if enabled and not autoplay)\n    if (this.config.videoHoverPlay && !this.config.videoAutoplay) {\n      video.addEventListener('mouseenter', () => {\n        video.currentTime = 0;\n        video.play().catch(() => {\n          // Ignore play errors (browser policies)\n        });\n      });\n\n      video.addEventListener('mouseleave', () => {\n        video.pause();\n        video.currentTime = 0;\n      });\n    }\n\n    return video;\n  }\n\n  /**\n   * Create image element with error handling\n   */\n  private createImageElement(url: string, originalElement: Element): HTMLImageElement {\n    const img = document.createElement('img');\n    \n    img.src = url;\n    img.alt = originalElement.getAttribute('alt') || 'Media content';\n    img.loading = 'lazy';\n    \n    // Maintain styling\n    img.style.width = '100%';\n    img.style.height = '100%';\n    img.style.objectFit = 'cover';\n    img.style.borderRadius = 'inherit';\n    \n    // Error handling\n    img.onerror = () => {\n      this.log(`Image failed to load: ${url}`);\n      img.style.background = '#f3f4f6';\n      img.style.opacity = '0.5';\n      img.alt = 'Image unavailable';\n      \n      // Add broken image icon\n      img.style.position = 'relative';\n      const placeholder = document.createElement('div');\n      placeholder.style.cssText = `\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #9ca3af;\n        font-size: 12px;\n        text-align: center;\n      `;\n      placeholder.textContent = ' Image unavailable';\n      img.parentElement?.appendChild(placeholder);\n    };\n\n    return img;\n  }\n\n  /**\n   * Extract video thumbnail from Cloudinary URL\n   */\n  private extractVideoThumbnail(videoUrl: string): string | null {\n    if (videoUrl.includes('cloudinary.com/') && videoUrl.includes('/video/')) {\n      // Convert video URL to image thumbnail\n      return videoUrl\n        .replace('/video/', '/image/')\n        .replace(/\\.(mp4|webm|mov|avi|mkv)$/i, '.jpg')\n        .replace('fl_progressive', 'f_auto,q_auto,c_fill');\n    }\n    return null;\n  }\n\n  /**\n   * Transfer attributes and classes from old element to new\n   */\n  private transferAttributes(from: Element, to: HTMLElement): void {\n    // Transfer classes\n    if (from.className) {\n      to.className = from.className;\n    }\n    \n    // Transfer data attributes (except contra-field)\n    Array.from(from.attributes).forEach(attr => {\n      if (attr.name.startsWith('data-') && attr.name !== `${ATTR_PREFIX}${ATTRS.field}`) {\n        to.setAttribute(attr.name, attr.value);\n      }\n    });\n    \n    // Transfer style\n    if (from.getAttribute('style')) {\n      const existingStyle = to.getAttribute('style') || '';\n      to.setAttribute('style', existingStyle + '; ' + from.getAttribute('style'));\n    }\n  }\n\n  /**\n   * Handle repeating elements (projects, social links)\n   */\n  private populateRepeatingElements(card: Element, expert: ExpertProfile): void {\n    const repeatElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.repeat}]`);\n    \n    repeatElements.forEach(container => {\n      const repeatType = this.getAttr(container, ATTRS.repeat);\n      const maxItems = parseInt(this.getAttr(container, ATTRS.max) || '10');\n      \n      if (repeatType === 'projects' && expert.projects) {\n        this.populateRepeatingContainer(container, expert.projects.slice(0, maxItems));\n      } else if (repeatType === 'socialLinks' && expert.socialLinks) {\n        this.populateRepeatingContainer(container, expert.socialLinks.slice(0, maxItems));\n      } else if (repeatType === 'skillTags' && expert.skillTags) {\n        this.populateRepeatingContainer(container, expert.skillTags.slice(0, maxItems).map((tag: string) => ({ name: tag })));\n      }\n    });\n  }\n\n  /**\n   * Populate a repeating container with items\n   */\n  private populateRepeatingContainer(container: Element, items: any[]): void {\n    const template = container.firstElementChild;\n    if (!template) return;\n\n    // Clear existing items\n    container.innerHTML = '';\n    \n    // Create items from template\n    items.forEach(item => {\n      const itemElement = template.cloneNode(true) as Element;\n      this.populateFields(itemElement, item);\n      container.appendChild(itemElement);\n    });\n    \n    // Hide container if no items\n    if (items.length === 0) {\n      (container as HTMLElement).style.display = 'none';\n    }\n  }\n\n  /**\n   * Handle conditional display based on data\n   */\n  private handleConditionalDisplay(card: Element, expert: ExpertProfile): void {\n    const conditionalElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.showWhen}], [${ATTR_PREFIX}${ATTRS.hideWhen}]`);\n    \n    conditionalElements.forEach(element => {\n      const showWhen = this.getAttr(element, ATTRS.showWhen);\n      const hideWhen = this.getAttr(element, ATTRS.hideWhen);\n      \n      let shouldShow = true;\n      \n      if (showWhen) {\n        shouldShow = this.evaluateCondition(expert, showWhen);\n      }\n      \n      if (hideWhen) {\n        shouldShow = shouldShow && !this.evaluateCondition(expert, hideWhen);\n      }\n      \n      (element as HTMLElement).style.display = shouldShow ? '' : 'none';\n    });\n  }\n\n  /**\n   * Evaluate a condition against expert data\n   */\n  private evaluateCondition(expert: ExpertProfile, condition: string): boolean {\n    if (!condition || typeof condition !== 'string') {\n      this.log('Invalid condition provided:', condition);\n      return false;\n    }\n    \n    const parts = condition.split(':');\n    const field = parts[0] as keyof ExpertProfile;\n    const expertValue = expert[field];\n\n    // Handle existence check (e.g., \"skillTags\" or \"projects\")\n    if (parts.length === 1) {\n      if (expertValue == null) return false;\n      \n      if (Array.isArray(expertValue)) {\n        const result = expertValue.length > 0;\n        this.log(`Existence check on array '${field}': length is ${expertValue.length}, result: ${result}`);\n        return result;\n      }\n      \n      const result = !!expertValue;\n      this.log(`Existence check on field '${field}': value is ${expertValue}, result: ${result}`);\n      return result;\n    }\n    \n    const expectedValue = parts.slice(1).join(':');\n    \n    if (expertValue == null) {\n      this.log(`Field '${field}' is null/undefined, condition fails for value: '${expectedValue}'`);\n      return false;\n    }\n    \n    this.log(`Evaluating condition: ${field} (${expertValue}, type: ${typeof expertValue}) against ${expectedValue}`);\n    \n    // Check for boolean comparison first\n    if (expectedValue === 'true' || expectedValue === 'false') {\n      const result = String(expertValue).toLowerCase() === expectedValue.toLowerCase();\n      this.log(`Boolean comparison: ${String(expertValue).toLowerCase()} === ${expectedValue} = ${result}`);\n      return result;\n    }\n\n    // Check for comparison operators\n    if (expectedValue.startsWith('>=')) {\n      const result = Number(expertValue) >= Number(expectedValue.substring(2));\n      this.log(`Comparison: ${expertValue} >= ${expectedValue.substring(2)} = ${result}`);\n      return result;\n    } else if (expectedValue.startsWith('<=')) {\n      const result = Number(expertValue) <= Number(expectedValue.substring(2));\n      this.log(`Comparison: ${expertValue} <= ${expectedValue.substring(2)} = ${result}`);\n      return result;\n    } else if (expectedValue.startsWith('>')) {\n      const result = Number(expertValue) > Number(expectedValue.substring(1));\n      this.log(`Comparison: ${expertValue} > ${expectedValue.substring(1)} = ${result}`);\n      return result;\n    } else if (expectedValue.startsWith('<')) {\n      const result = Number(expertValue) < Number(expectedValue.substring(1));\n      this.log(`Comparison: ${expertValue} < ${expectedValue.substring(1)} = ${result}`);\n      return result;\n    } else {\n      // Direct value comparison (case-insensitive for strings)\n      const result = String(expertValue).toLowerCase() === expectedValue.toLowerCase();\n      this.log(`String comparison: ${String(expertValue).toLowerCase()} === ${expectedValue.toLowerCase()} = ${result}`);\n      return result;\n    }\n  }\n\n  /**\n   * Update UI states based on current data\n   */\n  private updateUIStates(container: Element, programId: string): void {\n    const state = this.state.getState(programId);\n    \n    // Show/hide empty state\n    const emptyElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.empty}]`);\n    if (emptyElement) {\n      (emptyElement as HTMLElement).style.display = state.experts.length === 0 && !state.loading ? '' : 'none';\n    }\n    \n    // Update pagination info\n    const paginationElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationElements.forEach(element => {\n      const { currentPage, totalCount } = state;\n      const pageSize = state.filters.limit || 20;\n      const totalPages = Math.ceil(totalCount / pageSize);\n      \n      element.textContent = `Page ${currentPage} of ${totalPages} (${totalCount} total)`;\n    });\n    \n    // Update filter summaries\n    const filterSummaries = this.querySelectorAll(container, '[data-contra-filter-summary]');\n    filterSummaries.forEach(element => {\n      const activeFilters = Object.entries(state.filters)\n        .filter(([_key, value]) => value != null && value !== '')\n        .map(([key, value]) => `${key}: ${value}`)\n        .join(', ');\n      \n      element.textContent = activeFilters || 'No filters applied';\n    });\n  }\n\n  /**\n   * Handle action buttons with proper pagination logic\n   */\n  private handleAction(containerId: string, action: string, _target?: string | null, button?: Element): void {\n    const state = this.state.getState(containerId);\n    const container = document.querySelector(`[data-container-id=\"${containerId}\"]`);\n    \n    if (!container) {\n      this.log(`Container not found: ${containerId}`);\n      return;\n    }\n\n    // Show button feedback\n    if (button && button instanceof HTMLButtonElement) {\n      button.disabled = true;\n    }\n    \n    const limit = state.filters.limit || 20;\n    const currentOffset = state.filters.offset || 0;\n    \n    switch (action) {\n      case 'next-page':\n        if (state.paginationMode === 'traditional') {\n          const nextOffset = currentOffset + limit;\n          if (nextOffset < state.totalCount) {\n            this.updateFilter(containerId, 'offset', nextOffset);\n            this.loadExperts(container as Element, containerId, true);\n          }\n        } else {\n          // For infinite mode, use load more functionality\n          this.loadMoreExperts(container as Element, containerId);\n        }\n        break;\n        \n      case 'prev-page':\n        if (state.paginationMode === 'traditional') {\n          const prevOffset = Math.max(0, currentOffset - limit);\n          this.updateFilter(containerId, 'offset', prevOffset);\n          this.loadExperts(container as Element, containerId, true);\n        }\n        break;\n        \n      case 'first-page':\n        if (state.paginationMode === 'traditional') {\n          this.updateFilter(containerId, 'offset', 0);\n          this.loadExperts(container as Element, containerId, true);\n        }\n        break;\n        \n      case 'last-page':\n        if (state.paginationMode === 'traditional') {\n          const totalPages = Math.ceil(state.totalCount / limit);\n          const lastPageOffset = (totalPages - 1) * limit;\n          this.updateFilter(containerId, 'offset', lastPageOffset);\n          this.loadExperts(container as Element, containerId, true);\n        }\n        break;\n        \n      case 'load-more':\n        // Handle load more for infinite/hybrid modes\n        this.loadMoreExperts(container as Element, containerId).finally(() => {\n          if (button && button instanceof HTMLButtonElement) {\n            button.disabled = false;\n          }\n        });\n        return; // Exit early to avoid re-enabling button\n        \n      case 'reload':\n        // Clear cache and reload\n        this.state.updateState(containerId, { cachedPages: new Map() });\n        this.loadExperts(container as Element, containerId);\n        break;\n    }\n    \n    // Re-enable button after action completes\n    if (button && button instanceof HTMLButtonElement && action !== 'load-more') {\n      setTimeout(() => {\n        button.disabled = false;\n      }, 100);\n    }\n  }\n\n  /**\n   * Load more experts for infinite scroll mode\n   */\n  private async loadMoreExperts(container: Element, programId: string): Promise<void> {\n    const state = this.state.getState(programId);\n    \n    // Only allow load more for infinite/hybrid modes\n    if (state.paginationMode === 'traditional') {\n      this.log('Load more not supported in traditional pagination mode');\n      return;\n    }\n    \n    const limit = state.filters.limit || 20;\n    \n    // Calculate next offset based on currently loaded experts\n    const currentOffset = state.experts.length;\n    \n    this.log(`Loading more experts: currentOffset=${currentOffset}, limit=${limit}`);\n\n    try {\n      this.state.updateState(programId, { isInfiniteLoading: true });\n      this.updateLoadMoreButtonState(container, programId, true);\n\n      // Fetch next batch using current expert count as offset\n      const response = await this.client.listExperts(programId, {\n        ...state.filters,\n        offset: currentOffset,\n        limit: limit\n      });\n\n      this.log(`Loaded ${response.data.length} more experts from offset ${currentOffset}`);\n\n      // Handle the response using the infinite pagination handler\n      this.handleInfinitePaginationResponse(programId, container, response);\n\n    } catch (error) {\n      this.log(`Failed to load more experts`, error);\n      this.state.updateState(programId, { isInfiniteLoading: false });\n      \n      // Show error in load more button\n      this.updateLoadMoreButtonState(container, programId, false, 'Error loading more');\n      \n      setTimeout(() => {\n        this.updateLoadMoreButtonState(container, programId, false);\n      }, 3000);\n    } finally {\n      this.updateLoadMoreButtonState(container, programId, false);\n    }\n  }\n\n  /**\n   * Update load more button state\n   */\n  private updateLoadMoreButtonState(container: Element, programId: string, loading: boolean, errorText?: string): void {\n    const loadMoreButtons = this.querySelectorAll(container, '[data-contra-action=\"load-more\"]');\n    const state = this.state.getState(programId);\n    \n    loadMoreButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      \n      if (errorText) {\n        btnElement.textContent = errorText;\n        btnElement.disabled = true;\n        btnElement.classList.add('error');\n        return;\n      }\n      \n      btnElement.classList.remove('error');\n      \n      if (loading) {\n        btnElement.textContent = 'Loading...';\n        btnElement.disabled = true;\n        btnElement.classList.add('loading');\n      } else {\n        btnElement.classList.remove('loading');\n        const hasMore = state.experts.length < state.totalCount;\n        \n        if (hasMore) {\n          btnElement.textContent = this.config.loadMoreText;\n          btnElement.disabled = false;\n        } else {\n          btnElement.textContent = 'All experts loaded';\n          btnElement.disabled = true;\n          btnElement.classList.add('disabled');\n        }\n      }\n    });\n  }\n\n  /**\n   * Load next page for infinite scroll\n   */\n  private async loadNextPageInfinite(container: Element, programId: string): Promise<void> {\n    // Use the unified loadMoreExperts method\n    return this.loadMoreExperts(container, programId);\n  }\n\n  /**\n   * Update pagination control states based on current mode and state\n   */\n  private updatePaginationControls(container: Element, programId: string): void {\n    const state = this.state.getState(programId);\n    const limit = state.filters.limit || 20;\n    const totalPages = Math.ceil(state.totalCount / limit);\n    \n    if (state.paginationMode === 'traditional') {\n      this.updateTraditionalPaginationControls(container, state, totalPages);\n    } else {\n      this.updateInfinitePaginationControls(container, state);\n    }\n\n    this.log(`Pagination controls updated: mode=${state.paginationMode}, page=${state.currentPage}/${totalPages}, hasNext=${state.hasNextPage}`);\n  }\n\n  /**\n   * Update traditional pagination controls (Previous/Next buttons, page numbers)\n   */\n  private updateTraditionalPaginationControls(container: Element, state: any, totalPages: number): void {\n    // Update navigation buttons\n    const prevButtons = this.querySelectorAll(container, '[data-contra-action=\"prev-page\"]');\n    const nextButtons = this.querySelectorAll(container, '[data-contra-action=\"next-page\"]');\n    const firstButtons = this.querySelectorAll(container, '[data-contra-action=\"first-page\"]');\n    const lastButtons = this.querySelectorAll(container, '[data-contra-action=\"last-page\"]');\n\n    // Previous page buttons\n    prevButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = !state.hasPreviousPage;\n      btnElement.classList.toggle('disabled', !state.hasPreviousPage);\n    });\n\n    // Next page buttons\n    nextButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = !state.hasNextPage;\n      btnElement.classList.toggle('disabled', !state.hasNextPage);\n    });\n\n    // First page buttons\n    firstButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = state.currentPage <= 1;\n      btnElement.classList.toggle('disabled', state.currentPage <= 1);\n    });\n\n    // Last page buttons\n    lastButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = state.currentPage >= totalPages;\n      btnElement.classList.toggle('disabled', state.currentPage >= totalPages);\n    });\n\n    // Update pagination info elements\n    const paginationInfoElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationInfoElements.forEach(element => {\n      if (state.totalCount > 0) {\n        element.textContent = `Page ${state.currentPage} of ${totalPages} (${state.totalCount} total experts)`;\n      } else {\n        element.textContent = 'No experts found.';\n      }\n    });\n\n    // Show pagination controls if there are ANY results.\n    // This prevents the controls from disappearing when totalPages is 1,\n    // providing a consistent and stable UI.\n    const paginationSections = this.querySelectorAll(container, '.pagination-section');\n    this.log(`Updating pagination visibility. Total Pages: ${totalPages}, Total Count: ${state.totalCount}`);\n    paginationSections.forEach(section => {\n      (section as HTMLElement).style.display = state.totalCount > 0 ? '' : 'none';\n    });\n  }\n\n  /**\n   * Update infinite pagination controls (Load More button)\n   */\n  private updateInfinitePaginationControls(container: Element, state: any): void {\n    // Update load more buttons\n    this.updateLoadMoreButtonState(container, state.programId || 'default', state.isInfiniteLoading);\n\n    // Update pagination info elements for infinite mode\n    const paginationInfoElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationInfoElements.forEach(element => {\n      const loadedCount = state.experts.length;\n      const totalCount = state.totalCount;\n      element.textContent = `Showing ${loadedCount} of ${totalCount} experts`;\n    });\n\n    // Show pagination controls if there are any results.\n    const paginationSections = this.querySelectorAll(container, '.pagination-section');\n    paginationSections.forEach(section => {\n      (section as HTMLElement).style.display = state.totalCount > 0 ? '' : 'none';\n    });\n  }\n\n  /**\n   * Update infinite loading state\n   */\n  private updateInfiniteLoadingState(container: Element, loading: boolean): void {\n    const loadingIndicators = this.querySelectorAll(container, '[data-contra-infinite-loading]');\n    \n    loadingIndicators.forEach(indicator => {\n      (indicator as HTMLElement).style.display = loading ? '' : 'none';\n    });\n  }\n\n  /**\n   * Render new experts for infinite scroll (append mode)\n   */\n  private renderNewExperts(container: Element, newExperts: ExpertProfile[]): void {\n    // Find the grid where experts should be rendered. It MUST be a child of the container.\n    const targetGrid = this.querySelector(container, '.expert-grid');\n    \n    if (!targetGrid) {\n      this.log('CRITICAL: .expert-grid element not found inside container. Cannot append experts.', container);\n      return;\n    }\n    \n    // Find the template. It MUST be a direct child of the grid.\n    const template = this.querySelector(targetGrid, `[${ATTR_PREFIX}${ATTRS.template}]`);\n\n    if (!template) {\n      this.log('CRITICAL: Template element not found inside .expert-grid. Cannot append experts.', targetGrid);\n      return;\n    }\n\n    // Create a document fragment for efficient DOM manipulation\n    const fragment = document.createDocumentFragment();\n\n    newExperts.forEach(expert => {\n      const expertCard = this.populateExpertCard(template, expert);\n      fragment.appendChild(expertCard);\n    });\n\n    // Append all new cards at once to the grid\n    targetGrid.appendChild(fragment);\n\n    this.log(`Appended ${newExperts.length} new expert cards to`, targetGrid);\n  }\n\n  // ... (utility methods continue below)\n\n  /**\n   * Utility Methods\n   */\n  private getAttr(element: Element, name: string): string | null {\n    return element.getAttribute(`${ATTR_PREFIX}${name}`);\n  }\n\n  private querySelector(element: Element, selector: string): Element | null {\n    return element.querySelector(selector);\n  }\n\n  private querySelectorAll(element: Element, selector: string): Element[] {\n    return Array.from(element.querySelectorAll(selector));\n  }\n\n  private findExpertContainers(): Element[] {\n    this.log('Looking for expert containers...');\n    \n    // A container is DEFINED by being a grid-section.\n    // This is the most reliable way to find the top-level component boundaries.\n    const selector = `.grid-section`;\n    const containers = Array.from(document.querySelectorAll(selector));\n    \n    this.log(`Found ${containers.length} containers using selector: ${selector}`, containers);\n    return containers;\n  }\n\n  private parseFiltersFromElement(element: Element): ExpertFilters {\n    const filters: ExpertFilters = {};\n    \n    // Parse filter attributes\n    const filterMap = {\n      'available': 'available',\n      'languages': 'languages', \n      'location': 'location',\n      'min-rate': 'minRate',\n      'max-rate': 'maxRate',\n      'sort': 'sortBy',\n      'limit': 'limit',\n      'offset': 'offset'\n    };\n\n    Object.entries(filterMap).forEach(([attr, filterKey]) => {\n      const value = this.getAttr(element, attr);\n      if (value != null) {\n        if (filterKey === 'available') {\n          (filters as any)[filterKey] = value === 'true';\n        } else if (filterKey === 'languages') {\n          (filters as any)[filterKey] = value.split(',').map(v => v.trim());\n        } else if (['minRate', 'maxRate', 'limit', 'offset'].includes(filterKey)) {\n          (filters as any)[filterKey] = parseInt(value);\n        } else {\n          (filters as any)[filterKey] = value;\n        }\n      }\n    });\n\n    // Ensure offset defaults to 0 if not specified\n    if (filters.offset === undefined) {\n      filters.offset = 0;\n    }\n\n    return filters;\n  }\n\n  private getControlValue(control: HTMLInputElement | HTMLSelectElement): any {\n    if (control instanceof HTMLInputElement) {\n      switch (control.type) {\n        case 'checkbox':\n          return control.checked;\n        case 'number':\n        case 'range':\n          return control.valueAsNumber;\n        default:\n          return control.value;\n      }\n    } else if (control instanceof HTMLSelectElement) {\n      if (control.multiple) {\n        return Array.from(control.selectedOptions).map(option => option.value);\n      }\n      return control.value;\n    }\n    return null;\n  }\n\n  private updateFilter(programId: string, filterKey: string, value: any, type: string = 'replace'): void {\n    const state = this.state.getState(programId);\n    const newFilters = { ...state.filters };\n\n    // Handle special cases for filter value conversion to match OpenAPI spec (expects strings)\n    let processedValue: string | number | undefined = value;\n    \n    // Convert all values to strings, unless they are numbers for limit/offset.\n    // Handle empty/null values by setting them to undefined so they are omitted from the request.\n    if (value === null || value === '') {\n      processedValue = undefined;\n    } else if (typeof value === 'boolean') {\n      processedValue = String(value); // \"true\" or \"false\"\n    } else if (typeof value === 'number' && !['limit', 'offset', 'minRate', 'maxRate'].includes(filterKey)) {\n      processedValue = String(value);\n    }\n\n    if (type === 'append' && Array.isArray(newFilters[filterKey as keyof ExpertFilters])) {\n      const currentArray = newFilters[filterKey as keyof ExpertFilters] as any[];\n      (newFilters[filterKey as keyof ExpertFilters] as any) = [...currentArray, processedValue];\n    } else {\n      (newFilters as any)[filterKey] = processedValue;\n    }\n\n    // Reset offset to 0 when any filter changes (except offset itself)\n    // This ensures we start from the beginning when filters change\n    if (filterKey !== 'offset') {\n      newFilters.offset = 0;\n    }\n\n    // Remove keys with undefined values\n    Object.keys(newFilters).forEach(key => {\n      if ((newFilters as any)[key] === undefined) {\n        delete (newFilters as any)[key];\n      }\n    });\n\n    this.state.updateState(programId, { filters: newFilters });\n    \n    this.log(`Filter updated: ${filterKey} = ${processedValue} (final filters: `, newFilters, ')');\n    \n    // Dispatch filter change event\n    const event: FilterChangeEvent = {\n      filters: newFilters,\n      element: document.querySelector(`[data-container-id=\"${programId}\"]`) as HTMLElement\n    };\n    \n    this.dispatchEvent(document as any, 'filterChange', event);\n  }\n\n  private showLoading(container: Element, show: boolean): void {\n    const loadingElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.loading}]`);\n    if (loadingElement) {\n      (loadingElement as HTMLElement).style.display = show ? '' : 'none';\n    }\n    \n    (container as HTMLElement).classList.toggle(this.config.loadingClass, show);\n  }\n\n  private showError(container: Element, error: Error): void {\n    const errorElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.error}]`);\n    if (errorElement) {\n      errorElement.textContent = error.message;\n      (errorElement as HTMLElement).style.display = '';\n    }\n    \n    (container as HTMLElement).classList.add(this.config.errorClass);\n    this.log('Error displayed', error);\n  }\n\n  private dispatchEvent(target: Element | Document, eventName: string, detail: any): void {\n    const event = new CustomEvent(`contra:${eventName}`, { detail });\n    target.dispatchEvent(event);\n  }\n\n  private log(message: string, ...args: any[]): void {\n    if (this.config.debug) {\n      console.log(`[ContraWebflow] ${message}`, ...args);\n    }\n  }\n}\n\n/**\n * Auto-initialize runtime when DOM is ready\n */\nfunction autoInit(): void {\n  const configElement = document.getElementById('contra-config');\n  if (!configElement) {\n    console.warn('[ContraWebflow] No config element found. Runtime not initialized.');\n    return;\n  }\n\n  try {\n    const config = JSON.parse(configElement.textContent || '{}');\n    \n    // Validate required config\n    if (!config.apiKey) {\n      console.error('[ContraWebflow] API key is required in config.');\n      return;\n    }\n    \n    if (!config.program) {\n      console.error('[ContraWebflow] Program ID is required in config.');\n      return;\n    }\n    \n    // Add a small delay to ensure all DOM elements are ready\n    const initializeRuntime = () => {\n      const runtime = new ContraWebflowRuntime(config);\n      \n      // Expose runtime globally for debugging\n      (window as any).contraRuntime = runtime;\n      \n      runtime.init().catch(error => {\n        console.error('[ContraWebflow] Runtime initialization failed:', error);\n      });\n    };\n    \n    // Use setTimeout to ensure DOM is fully ready\n    setTimeout(initializeRuntime, 100);\n    \n  } catch (error) {\n    console.error('[ContraWebflow] Failed to parse config:', error);\n  }\n}\n\n// Auto-initialize when DOM is ready with multiple fallbacks\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else if (document.readyState === 'interactive') {\n  // DOM is ready but resources might still be loading\n  setTimeout(autoInit, 50);\n} else {\n  // DOM and resources are ready\n  autoInit();\n}\n\n// Export runtime class for manual initialization\nexport { ContraWebflowRuntime as default };"]}