{"version":3,"sources":["../src/runtime.ts","../../contra-client/src/client.ts"],"sourcesContent":["import { ContraClient, utils } from '@contra/client';\nimport type {\n  ExpertProfile,\n  ExpertFilters,\n  FilterChangeEvent,\n  ExpertLoadEvent,\n  ErrorEvent,\n  ExpertField\n} from '@contra/types';\n\n/**\n * Webflow Runtime for Contra Experts\n * Features: Performance optimization, filtering, error handling, loading states\n */\n\n// Configuration interface\ninterface RuntimeConfig {\n  apiKey: string;\n  program?: string;  // Program ID from config\n  debug?: boolean;\n  loadingClass?: string;\n  errorClass?: string;\n  emptyClass?: string;\n  autoReload?: boolean;\n  debounceDelay?: number;\n  maxRetries?: number;\n  \n  // Pagination Configuration\n  paginationMode?: 'traditional' | 'infinite' | 'hybrid';\n  infiniteScrollThreshold?: number;        // Pixels from bottom to trigger load\n  preloadNextPage?: boolean;              // Preload next page for performance\n  maxCachedPages?: number;                // Max pages to keep in memory\n  smoothScrollBehavior?: 'auto' | 'smooth';\n  loadMoreText?: string;                  // Custom \"Load More\" button text\n  \n  // Video configuration\n  videoAutoplay?: boolean;\n  videoHoverPlay?: boolean;\n  videoMuted?: boolean;\n  videoLoop?: boolean;\n  videoControls?: boolean;\n}\n\n// Attribute constants\nconst ATTR_PREFIX = 'data-contra-';\nconst ATTRS = {\n  // Core attributes\n  program: 'program',\n  template: 'template',\n  loading: 'loading',\n  error: 'error',\n  empty: 'empty',\n  \n  // Field binding\n  field: 'field',\n  format: 'format',\n  \n  // Repeating elements\n  repeat: 'repeat',\n  max: 'max',\n  \n  // Filter controls\n  filter: 'filter',\n  filterType: 'filter-type',\n  \n  // Filter attributes\n  available: 'available',\n  \n  // Sorting and pagination\n  sort: 'sort',\n  page: 'page',\n  limit: 'limit',\n  \n  // Pagination mode and controls\n  paginationMode: 'pagination-mode',\n  infiniteLoading: 'infinite-loading',\n  paginationInfo: 'pagination-info',\n  \n  // UI states\n  showWhen: 'show-when',\n  hideWhen: 'hide-when',\n  \n  // Actions\n  action: 'action',\n  target: 'target'\n} as const;\n\n// State management\nclass RuntimeState {\n  private states = new Map<string, {\n    filters: ExpertFilters;\n    experts: ExpertProfile[];\n    loading: boolean;\n    error: Error | null;\n    currentPage: number;\n    totalCount: number;\n    // Advanced pagination state\n    cachedPages: Map<number, ExpertProfile[]>;\n    loadingPages: Set<number>;\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n    isInfiniteLoading: boolean;\n    lastScrollPosition: number;\n    paginationMode: 'traditional' | 'infinite' | 'hybrid';\n    programId: string;\n  }>();\n\n  getState(programId: string) {\n    if (!this.states.has(programId)) {\n      this.states.set(programId, {\n        filters: {},\n        experts: [],\n        loading: false,\n        error: null,\n        currentPage: 1,\n        totalCount: 0,\n        // Advanced pagination defaults\n        cachedPages: new Map(),\n        loadingPages: new Set(),\n        hasNextPage: false,\n        hasPreviousPage: false,\n        isInfiniteLoading: false,\n        lastScrollPosition: 0,\n        paginationMode: 'traditional',\n        programId: ''\n      });\n    }\n    return this.states.get(programId)!;\n  }\n\n  updateState(programId: string, updates: Partial<ReturnType<RuntimeState['getState']>>) {\n    const state = this.getState(programId);\n    Object.assign(state, updates);\n    this.states.set(programId, state);\n  }\n\n  // Advanced pagination helpers\n  cachePage(programId: string, pageNumber: number, experts: ExpertProfile[]) {\n    const state = this.getState(programId);\n    state.cachedPages.set(pageNumber, experts);\n    \n    // Implement LRU cache cleanup\n    if (state.cachedPages.size > 5) { // maxCachedPages from config\n      const oldestPage = Math.min(...state.cachedPages.keys());\n      state.cachedPages.delete(oldestPage);\n    }\n  }\n\n  getCachedPage(programId: string, pageNumber: number): ExpertProfile[] | null {\n    const state = this.getState(programId);\n    return state.cachedPages.get(pageNumber) || null;\n  }\n\n  setPageLoading(programId: string, pageNumber: number, loading: boolean) {\n    const state = this.getState(programId);\n    if (loading) {\n      state.loadingPages.add(pageNumber);\n    } else {\n      state.loadingPages.delete(pageNumber);\n    }\n  }\n\n  isPageLoading(programId: string, pageNumber: number): boolean {\n    const state = this.getState(programId);\n    return state.loadingPages.has(pageNumber);\n  }\n}\n\n/**\n * Main Runtime Class\n */\nexport class ContraWebflowRuntime {\n  private client: ContraClient;\n  private config: Required<RuntimeConfig>;\n  private state = new RuntimeState();\n  private debouncedReload: Map<string, () => void> = new Map();\n\n  constructor(config: RuntimeConfig) {\n    this.config = {\n      debug: false,\n      program: '',  // Default empty program\n      loadingClass: 'loading',\n      errorClass: 'error',\n      emptyClass: 'empty',\n      autoReload: true,\n      debounceDelay: 300,\n      maxRetries: 3,\n      // Pagination Configuration defaults\n      paginationMode: 'traditional',\n      infiniteScrollThreshold: 500,\n      preloadNextPage: true,\n      maxCachedPages: 5,\n      smoothScrollBehavior: 'auto',\n      loadMoreText: 'Load More',\n      // Video configuration defaults\n      videoAutoplay: false,      // No autoplay by default (better UX)\n      videoHoverPlay: true,       // Hover to play by default\n      videoMuted: true,           // Muted for autoplay compatibility\n      videoLoop: true,            // Loop videos\n      videoControls: false,       // No controls for cleaner look\n      ...config\n    };\n\n    this.client = new ContraClient({\n      apiKey: this.config.apiKey,\n      debug: this.config.debug\n    });\n\n    this.log('Runtime initialized', this.config);\n  }\n\n  /**\n   * Initialize the runtime and find all expert containers\n   */\n  async init(): Promise<void> {\n    this.log('Initializing runtime...');\n\n    try {\n      // Find all expert containers\n      const allContainers = this.findExpertContainers();\n      // Filter out already initialized containers\n      const containers = allContainers.filter(container => \n        !container.hasAttribute('data-contra-initialized')\n      );\n      \n      this.log(`Found ${containers.length} uninitialised expert containers (${allContainers.length} total)`);\n\n      // Initialize each container\n      for (const container of containers) {\n        await this.initContainer(container);\n      }\n\n      this.log('Runtime initialization complete');\n    } catch (error) {\n      this.log('Runtime initialization failed', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize a single expert container\n   */\n  private async initContainer(container: Element): Promise<void> {\n    // Get program ID from config\n    const programId = this.config.program;\n    if (!programId) {\n      this.log('No program ID found in config', container);\n      return;\n    }\n\n    // Create simple container identifier\n    const containers = document.querySelectorAll('[data-contra-limit], [data-contra-pagination]');\n    const containerIndex = Array.from(containers).indexOf(container);\n    const containerId = `container-${containerIndex}`;\n\n    this.log(`Initializing container ${containerId} for program: ${programId}`);\n\n    try {\n      // Setup container state\n      this.setupContainer(container, containerId, programId);\n      \n      // Wire up filter controls\n      this.wireFilterControls(container, containerId);\n      \n      // Wire up action buttons\n      this.wireActionButtons(container, containerId);\n      \n      // Setup debounced reload for this container\n      this.setupDebouncedReload(containerId);\n      \n      // Load initial data\n      await this.loadExperts(container, containerId);\n\n    } catch (error) {\n      this.log(`Failed to initialize container ${containerId}`, error);\n      this.showError(container, error as Error);\n    }\n  }\n\n  /**\n   * Setup debounced reload for a container\n   */\n  private setupDebouncedReload(containerId: string): void {\n    let timeout: NodeJS.Timeout;\n    this.debouncedReload.set(containerId, () => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        const container = document.querySelector(`[data-container-id=\"${containerId}\"]`);\n        if (container) {\n          this.loadExperts(container as Element, containerId);\n        }\n      }, this.config.debounceDelay);\n    });\n  }\n\n  /**\n   * Setup container with initial state and classes\n   */\n  private setupContainer(container: Element, containerId: string, programId: string): void {\n    const element = container as HTMLElement;\n    \n    // Add runtime classes and identifier\n    element.classList.add('contra-runtime');\n    element.setAttribute('data-contra-initialized', 'true');\n    element.setAttribute('data-container-id', containerId);\n    \n    // Parse pagination mode and settings\n    const paginationMode = this.getAttr(container, 'pagination') || 'traditional';\n    const limit = parseInt(this.getAttr(container, 'limit') || '20');\n    \n    // Initialize container state\n    this.state.updateState(containerId, { \n      filters: { limit, offset: 0 },\n      paginationMode: paginationMode as 'traditional' | 'infinite',\n      experts: [],\n      loading: false,\n      error: null,\n      currentPage: 1,\n      totalCount: 0,\n      hasNextPage: false,\n      hasPreviousPage: false,\n      cachedPages: new Map(),\n      loadingPages: new Set(),\n      isInfiniteLoading: false,\n      lastScrollPosition: 0,\n      programId: programId\n    });\n    \n    this.log(`Container ${containerId} setup complete:`, { paginationMode, limit });\n  }\n\n  /**\n   * Wire up filter controls to auto-update\n   */\n  private wireFilterControls(container: Element, containerId: string): void {\n    const filterControls = this.querySelectorAll(container, `[${ATTR_PREFIX}${ATTRS.filter}]`);\n    \n    this.log(`Found ${filterControls.length} filter controls for container: ${containerId}`);\n\n    filterControls.forEach(control => {\n      const filterKey = this.getAttr(control, ATTRS.filter);\n      const filterType = this.getAttr(control, ATTRS.filterType) || 'replace';\n      \n      if (!filterKey) return;\n\n      // Add event listeners based on control type\n      if (control instanceof HTMLInputElement) {\n        const eventType = control.type === 'range' || control.type === 'number' ? 'input' : 'change';\n        \n        control.addEventListener(eventType, () => {\n          this.updateFilter(containerId, filterKey, this.getControlValue(control), filterType);\n          if (this.config.autoReload) {\n            this.debouncedReload.get(containerId)?.();\n          }\n        });\n        \n      } else if (control instanceof HTMLSelectElement) {\n        control.addEventListener('change', () => {\n          this.updateFilter(containerId, filterKey, this.getControlValue(control), filterType);\n          if (this.config.autoReload) {\n            this.debouncedReload.get(containerId)?.();\n          }\n        });\n      }\n      \n      this.log(`Wired filter control: ${filterKey} (${filterType})`, control);\n    });\n  }\n\n  /**\n   * Wire up action buttons (pagination, sorting, etc.)\n   */\n  private wireActionButtons(container: Element, containerId: string): void {\n    const actionButtons = this.querySelectorAll(container, `[${ATTR_PREFIX}${ATTRS.action}]`);\n    \n    actionButtons.forEach(button => {\n      const action = this.getAttr(button, ATTRS.action);\n      const target = this.getAttr(button, ATTRS.target);\n      \n      if (!action) return;\n\n      button.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.handleAction(containerId, action, target, button);\n      });\n    });\n  }\n\n  /**\n   * Load experts for a container with proper pagination handling\n   */\n  private async loadExperts(container: Element, containerId: string, isPageNavigation = false): Promise<void> {\n    const state = this.state.getState(containerId);\n    const programId = state.programId;\n    \n    this.log(`Loading experts for container: ${containerId}, program: ${programId}`, state.filters);\n\n    try {\n      // Show loading state\n      this.showLoading(container, true);\n      this.state.updateState(containerId, { loading: true, error: null });\n\n      // Fetch experts from API\n      const response = await this.client.listExperts(programId, state.filters);\n      \n      this.log(`Loaded ${response.data.length} experts`, response);\n\n      // Update pagination state based on mode\n      if (state.paginationMode === 'traditional') {\n        this.handleTraditionalPaginationResponse(containerId, container, response);\n      } else {\n        this.handleInfinitePaginationResponse(containerId, container, response);\n      }\n\n    } catch (error) {\n      this.log(`Failed to load experts for container: ${containerId}`, error);\n      \n      this.state.updateState(containerId, { \n        loading: false, \n        error: error as Error \n      });\n      \n      this.showError(container, error as Error);\n      \n      // Dispatch error event\n      this.dispatchEvent(container, 'expertsError', {\n        error: error as Error,\n        context: `Loading experts for container ${containerId}`\n      } as ErrorEvent);\n    } finally {\n      this.showLoading(container, false);\n    }\n  }\n\n  /**\n   * Handle traditional pagination response (page-based navigation)\n   */\n  private handleTraditionalPaginationResponse(\n    containerId: string, \n    container: Element, \n    response: { data: ExpertProfile[], totalCount: number }\n  ): void {\n    const state = this.state.getState(containerId);\n    \n    // Calculate pagination metadata\n    const limit = state.filters.limit || 20;\n    const offset = state.filters.offset || 0;\n    const currentPage = Math.floor(offset / limit) + 1;\n    const totalPages = Math.ceil(response.totalCount / limit);\n    const hasNextPage = currentPage < totalPages;\n    const hasPreviousPage = currentPage > 1;\n\n    // Update state\n    this.state.updateState(containerId, {\n      experts: response.data,\n      totalCount: response.totalCount,\n      currentPage: currentPage,\n      hasNextPage: hasNextPage,\n      hasPreviousPage: hasPreviousPage,\n      loading: false\n    });\n\n    // Cache the page\n    this.state.cachePage(containerId, currentPage, response.data);\n\n    // Render experts (replace mode for traditional pagination)\n    this.renderExperts(container, response.data);\n    \n    // Update UI\n    this.updateUIStates(container, containerId);\n    this.updatePaginationControls(container, containerId);\n    \n    // Dispatch event\n    this.dispatchEvent(container, 'expertsLoaded', {\n      experts: response.data,\n      totalCount: response.totalCount,\n      filters: state.filters,\n      page: currentPage,\n      totalPages: totalPages,\n      hasNextPage: hasNextPage,\n      hasPreviousPage: hasPreviousPage,\n      paginationMode: 'traditional'\n    } as ExpertLoadEvent);\n\n    this.log(`Traditional pagination: Page ${currentPage}/${totalPages}, ${response.data.length} experts loaded`);\n  }\n\n  /**\n   * Handle infinite pagination response (cumulative loading)\n   */\n  private handleInfinitePaginationResponse(\n    containerId: string, \n    container: Element, \n    response: { data: ExpertProfile[], totalCount: number }\n  ): void {\n    const state = this.state.getState(containerId);\n    const isLoadMore = state.experts.length > 0;\n    \n    // For infinite loading, append to existing experts\n    const allExperts = isLoadMore ? [...state.experts, ...response.data] : response.data;\n    const hasNextPage = allExperts.length < response.totalCount;\n    \n    // Update state\n    this.state.updateState(containerId, {\n      experts: allExperts,\n      totalCount: response.totalCount,\n      hasNextPage: hasNextPage,\n      hasPreviousPage: false, // Not applicable for infinite scroll\n      loading: false,\n      isInfiniteLoading: false\n    });\n\n    // Render experts (append mode for infinite loading)\n    if (isLoadMore) {\n      this.renderNewExperts(container, response.data);\n    } else {\n      this.renderExperts(container, response.data);\n    }\n    \n    // Update UI\n    this.updateUIStates(container, containerId);\n    this.updatePaginationControls(container, containerId);\n    \n    // Dispatch event\n    this.dispatchEvent(container, 'expertsLoaded', {\n      experts: response.data,\n      totalExperts: allExperts,\n      totalCount: response.totalCount,\n      filters: state.filters,\n      hasNextPage: hasNextPage,\n      isLoadMore: isLoadMore,\n      paginationMode: 'infinite'\n    } as ExpertLoadEvent);\n\n    this.log(`Infinite pagination: ${allExperts.length}/${response.totalCount} experts loaded`);\n  }\n\n  /**\n   * Calculate current page from filters\n   */\n  private calculateCurrentPage(filters: ExpertFilters): number {\n    const limit = filters.limit || 20;\n    const offset = filters.offset || 0;\n    return Math.floor(offset / limit) + 1;\n  }\n\n  /**\n   * Update pagination state consistently\n   */\n  private updatePaginationState(\n    programId: string, \n    experts: ExpertProfile[], \n    totalCount: number, \n    filters: ExpertFilters\n  ): void {\n    const limit = filters.limit || 20;\n    const offset = filters.offset || 0;\n    const currentPage = Math.floor(offset / limit) + 1;\n    const totalPages = Math.ceil(totalCount / limit);\n    \n    this.state.updateState(programId, {\n      experts: experts,\n      totalCount: totalCount,\n      currentPage: currentPage,\n      hasNextPage: currentPage < totalPages,\n      hasPreviousPage: currentPage > 1,\n      loading: false\n    });\n  }\n\n  /**\n   * Render experts into the container\n   */\n  private renderExperts(container: Element, experts: ExpertProfile[]): void {\n    // Look for template in the container or its expert-grid child\n    let template = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.template}]`);\n    let targetContainer = container;\n    \n    // If template not found directly, look in expert-grid child\n    if (!template) {\n      const expertGrid = this.querySelector(container, '.expert-grid');\n      if (expertGrid) {\n        template = this.querySelector(expertGrid, `[${ATTR_PREFIX}${ATTRS.template}]`);\n        targetContainer = expertGrid;\n      }\n    }\n    \n    if (!template) {\n      this.log('No template found in container or expert-grid', container);\n      return;\n    }\n\n    // Clear existing expert cards (only remove cards that were previously rendered)\n    // Keep template, state elements, filters, pagination, and other controls\n    const existingCards = this.querySelectorAll(targetContainer, '.expert-card:not([data-contra-template])');\n    existingCards.forEach(card => card.remove());\n\n    // Render expert cards\n    experts.forEach(expert => {\n      const expertCard = this.populateExpertCard(template, expert);\n      targetContainer.appendChild(expertCard);\n    });\n\n    this.log(`Rendered ${experts.length} expert cards in`, targetContainer);\n  }\n\n  /**\n   * Populate expert card from template\n   */\n  private populateExpertCard(template: Element, expert: ExpertProfile): Element {\n    const card = template.cloneNode(true) as Element;\n    \n    // Remove template attribute and show the card\n    card.removeAttribute(`${ATTR_PREFIX}${ATTRS.template}`);\n    (card as HTMLElement).style.display = '';\n\n    // Populate field bindings\n    this.populateFields(card, expert);\n    \n    // Handle repeating elements (projects, social links)\n    this.populateRepeatingElements(card, expert);\n    \n    // Handle conditional display\n    this.handleConditionalDisplay(card, expert);\n\n    return card;\n  }\n\n  /**\n   * Populate data fields in the card\n   */\n  private populateFields(card: Element, expert: ExpertProfile): void {\n    const fieldElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.field}]`);\n    \n    fieldElements.forEach(element => {\n      const fieldName = this.getAttr(element, ATTRS.field) as ExpertField;\n      const format = this.getAttr(element, ATTRS.format);\n      \n      if (!fieldName || !(fieldName in expert)) return;\n\n      const value = expert[fieldName];\n      this.setElementValue(element, value, format);\n    });\n\n    // Handle star ratings\n    const starsElements = this.querySelectorAll(card, '[data-contra-stars]');\n    starsElements.forEach(element => {\n      if (expert.averageReviewScore) {\n        this.renderStarRating(element, expert.averageReviewScore);\n      }\n    });\n  }\n\n  /**\n   * Set element value with proper formatting\n   */\n  private setElementValue(element: Element, value: any, format?: string | null): void {\n    if (value == null || value === '') return;\n\n    // Media type detection and handling\n    if (this.isMediaField(element) && typeof value === 'string' && value.trim()) {\n      this.setMediaValue(element, value);\n      return;\n    }\n\n    if (element instanceof HTMLAnchorElement) {\n      element.href = String(value);\n      if (!element.textContent?.trim()) {\n        element.textContent = String(value);\n      }\n    } else if (element instanceof HTMLInputElement) {\n      element.value = String(value);\n    } else if (element instanceof HTMLImageElement) {\n      // Regular image handling for avatars and other images\n      element.src = String(value);\n      element.alt = element.alt || 'Image';\n    } else {\n      // Text content with formatting\n      let displayValue = String(value);\n      \n      if (format) {\n        switch (format) {\n          case 'currency':\n            displayValue = typeof value === 'number' ? `$${value}` : displayValue;\n            break;\n          case 'rate':\n            displayValue = utils.formatRate(typeof value === 'number' ? value : null);\n            break;\n          case 'rating':\n            // Format rating to one decimal place (5.0, 4.9, etc.)\n            displayValue = typeof value === 'number' ? value.toFixed(1) : displayValue;\n            break;\n          case 'earnings':\n            // Format earnings like $25k+\n            if (typeof value === 'number') {\n              if (value >= 1000000) {\n                displayValue = `$${Math.floor(value / 1000000)}M+`;\n              } else if (value >= 1000) {\n                displayValue = `$${Math.floor(value / 1000)}k+`;\n              } else {\n                displayValue = `$${value}`;\n              }\n            }\n            break;\n          case 'number':\n            displayValue = typeof value === 'number' ? value.toLocaleString() : displayValue;\n            break;\n          case 'truncate':\n            displayValue = displayValue.length > 100 ? displayValue.substring(0, 97) + '...' : displayValue;\n            break;\n          case 'boolean':\n            displayValue = value ? 'Yes' : 'No';\n            break;\n          case 'availability':\n            displayValue = value ? 'Available' : 'Not Available';\n            break;\n        }\n      }\n      \n      element.textContent = displayValue;\n    }\n  }\n\n  /**\n   * Star rating rendering with optional text display\n   */\n  private renderStarRating(element: Element, rating: number): void {\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = rating % 1 >= 0.5;\n    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);\n    \n    let starsHtml = '';\n    \n    // Full stars\n    for (let i = 0; i < fullStars; i++) {\n      starsHtml += '<span class=\"contra-star contra-star-full\">★</span>';\n    }\n    \n    // Half star\n    if (hasHalfStar) {\n      starsHtml += '<span class=\"contra-star contra-star-half\">★</span>';\n    }\n    \n    // Empty stars\n    for (let i = 0; i < emptyStars; i++) {\n      starsHtml += '<span class=\"contra-star contra-star-empty\">☆</span>';\n    }\n    \n    element.innerHTML = starsHtml;\n    \n    // Also update any rating text elements in the same card\n    const card = element.closest('[data-contra-template]') || element.closest('.expert-card');\n    if (card) {\n      const ratingTextElements = this.querySelectorAll(card, '[data-contra-rating-text]');\n      ratingTextElements.forEach(textElement => {\n        textElement.textContent = rating.toFixed(1);\n      });\n    }\n  }\n\n  /**\n   * Media type detection and element handling\n   */\n  private isMediaField(element: Element): boolean {\n    const field = this.getAttr(element, ATTRS.field);\n    // Only apply advanced media handling to project cover URLs, not avatars\n    return field === 'coverUrl';\n  }\n\n  /**\n   * Media value setting with automatic type detection\n   */\n  private setMediaValue(element: Element, url: string): void {\n    const mediaType = this.detectMediaType(url);\n    const parent = element.parentElement;\n    \n    if (!parent) {\n      this.log('Media element has no parent for replacement', element);\n      return;\n    }\n\n    // Remove existing media element\n    element.remove();\n\n    // Create appropriate media element\n    let mediaElement: HTMLElement;\n    \n    switch (mediaType) {\n      case 'video':\n        mediaElement = this.createVideoElement(url, element);\n        break;\n      case 'image':\n      default:\n        mediaElement = this.createImageElement(url, element);\n        break;\n    }\n\n    // Preserve classes and attributes from original element\n    this.transferAttributes(element, mediaElement);\n    \n    // Insert new media element\n    parent.appendChild(mediaElement);\n    \n    this.log(`Created ${mediaType} element for URL: ${url}`);\n  }\n\n  /**\n   * Detect media type from URL\n   */\n  private detectMediaType(url: string): 'image' | 'video' {\n    if (!url || typeof url !== 'string') {\n      this.log('Invalid URL provided to detectMediaType:', url);\n      return 'image';\n    }\n    \n    const urlLower = url.toLowerCase();\n    \n    // Video formats\n    const videoExtensions = ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.ogg'];\n    const isVideo = videoExtensions.some(ext => urlLower.includes(ext));\n    \n    // Special handling for Cloudinary video URLs\n    const isCloudinaryVideo = urlLower.includes('cloudinary.com/') && urlLower.includes('/video/');\n    \n    return (isVideo || isCloudinaryVideo) ? 'video' : 'image';\n  }\n\n  /**\n   * Create video element with fallback\n   */\n  private createVideoElement(url: string, originalElement: Element): HTMLVideoElement {\n    const video = document.createElement('video');\n    \n    // Video attributes\n    video.src = url;\n    video.muted = this.config.videoMuted;\n    video.loop = this.config.videoLoop;\n    video.playsInline = true;\n    video.preload = 'metadata';\n    video.controls = this.config.videoControls;\n    \n    // Maintain aspect ratio and object-fit from original\n    video.style.width = '100%';\n    video.style.height = '100%';\n    video.style.objectFit = 'cover';\n    video.style.borderRadius = 'inherit';\n    \n    // Autoplay configuration\n    if (this.config.videoAutoplay) {\n      video.autoplay = true;\n      video.setAttribute('autoplay', '');\n    }\n    \n    // Error handling with fallback to poster or placeholder\n    video.onerror = () => {\n      this.log(`Video failed to load: ${url}`);\n      // Try to extract a thumbnail from Cloudinary video URL\n      const posterUrl = this.extractVideoThumbnail(url);\n      if (posterUrl) {\n        const fallbackImg = this.createImageElement(posterUrl, originalElement);\n        video.parentElement?.replaceChild(fallbackImg, video);\n      } else {\n        // Show placeholder\n        video.style.background = '#f3f4f6';\n        video.style.position = 'relative';\n        video.innerHTML = '<div style=\"position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#9ca3af;font-size:12px;\">Video unavailable</div>';\n      }\n    };\n\n    // Hover-to-play functionality (if enabled and not autoplay)\n    if (this.config.videoHoverPlay && !this.config.videoAutoplay) {\n      video.addEventListener('mouseenter', () => {\n        video.currentTime = 0;\n        video.play().catch(() => {\n          // Ignore play errors (browser policies)\n        });\n      });\n\n      video.addEventListener('mouseleave', () => {\n        video.pause();\n        video.currentTime = 0;\n      });\n    }\n\n    return video;\n  }\n\n  /**\n   * Create image element with error handling\n   */\n  private createImageElement(url: string, originalElement: Element): HTMLImageElement {\n    const img = document.createElement('img');\n    \n    img.src = url;\n    img.alt = originalElement.getAttribute('alt') || 'Media content';\n    img.loading = 'lazy';\n    \n    // Maintain styling\n    img.style.width = '100%';\n    img.style.height = '100%';\n    img.style.objectFit = 'cover';\n    img.style.borderRadius = 'inherit';\n    \n    // Error handling\n    img.onerror = () => {\n      this.log(`Image failed to load: ${url}`);\n      img.style.background = '#f3f4f6';\n      img.style.opacity = '0.5';\n      img.alt = 'Image unavailable';\n      \n      // Add broken image icon\n      img.style.position = 'relative';\n      const placeholder = document.createElement('div');\n      placeholder.style.cssText = `\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #9ca3af;\n        font-size: 12px;\n        text-align: center;\n      `;\n      placeholder.textContent = '🖼️ Image unavailable';\n      img.parentElement?.appendChild(placeholder);\n    };\n\n    return img;\n  }\n\n  /**\n   * Extract video thumbnail from Cloudinary URL\n   */\n  private extractVideoThumbnail(videoUrl: string): string | null {\n    if (videoUrl.includes('cloudinary.com/') && videoUrl.includes('/video/')) {\n      // Convert video URL to image thumbnail\n      return videoUrl\n        .replace('/video/', '/image/')\n        .replace(/\\.(mp4|webm|mov|avi|mkv)$/i, '.jpg')\n        .replace('fl_progressive', 'f_auto,q_auto,c_fill');\n    }\n    return null;\n  }\n\n  /**\n   * Transfer attributes and classes from old element to new\n   */\n  private transferAttributes(from: Element, to: HTMLElement): void {\n    // Transfer classes\n    if (from.className) {\n      to.className = from.className;\n    }\n    \n    // Transfer data attributes (except contra-field)\n    Array.from(from.attributes).forEach(attr => {\n      if (attr.name.startsWith('data-') && attr.name !== `${ATTR_PREFIX}${ATTRS.field}`) {\n        to.setAttribute(attr.name, attr.value);\n      }\n    });\n    \n    // Transfer style\n    if (from.getAttribute('style')) {\n      const existingStyle = to.getAttribute('style') || '';\n      to.setAttribute('style', existingStyle + '; ' + from.getAttribute('style'));\n    }\n  }\n\n  /**\n   * Handle repeating elements (projects, social links)\n   */\n  private populateRepeatingElements(card: Element, expert: ExpertProfile): void {\n    const repeatElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.repeat}]`);\n    \n    repeatElements.forEach(container => {\n      const repeatType = this.getAttr(container, ATTRS.repeat);\n      const maxItems = parseInt(this.getAttr(container, ATTRS.max) || '10');\n      \n      if (repeatType === 'projects' && expert.projects) {\n        this.populateRepeatingContainer(container, expert.projects.slice(0, maxItems));\n      } else if (repeatType === 'socialLinks' && expert.socialLinks) {\n        this.populateRepeatingContainer(container, expert.socialLinks.slice(0, maxItems));\n      } else if (repeatType === 'skillTags' && expert.skillTags) {\n        this.populateRepeatingContainer(container, expert.skillTags.slice(0, maxItems).map((tag: string) => ({ name: tag })));\n      }\n    });\n  }\n\n  /**\n   * Populate a repeating container with items\n   */\n  private populateRepeatingContainer(container: Element, items: any[]): void {\n    const template = container.firstElementChild;\n    if (!template) return;\n\n    // Clear existing items\n    container.innerHTML = '';\n    \n    // Create items from template\n    items.forEach(item => {\n      const itemElement = template.cloneNode(true) as Element;\n      this.populateFields(itemElement, item);\n      container.appendChild(itemElement);\n    });\n    \n    // Hide container if no items\n    if (items.length === 0) {\n      (container as HTMLElement).style.display = 'none';\n    }\n  }\n\n  /**\n   * Handle conditional display based on data\n   */\n  private handleConditionalDisplay(card: Element, expert: ExpertProfile): void {\n    const conditionalElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.showWhen}], [${ATTR_PREFIX}${ATTRS.hideWhen}]`);\n    \n    conditionalElements.forEach(element => {\n      const showWhen = this.getAttr(element, ATTRS.showWhen);\n      const hideWhen = this.getAttr(element, ATTRS.hideWhen);\n      \n      let shouldShow = true;\n      \n      if (showWhen) {\n        shouldShow = this.evaluateCondition(expert, showWhen);\n      }\n      \n      if (hideWhen) {\n        shouldShow = shouldShow && !this.evaluateCondition(expert, hideWhen);\n      }\n      \n      (element as HTMLElement).style.display = shouldShow ? '' : 'none';\n    });\n  }\n\n  /**\n   * Evaluate a condition against expert data\n   */\n  private evaluateCondition(expert: ExpertProfile, condition: string): boolean {\n    if (!condition || typeof condition !== 'string') {\n      this.log('Invalid condition provided:', condition);\n      return false;\n    }\n    \n    const parts = condition.split(':');\n    const field = parts[0] as keyof ExpertProfile;\n    const expertValue = expert[field];\n\n    // Handle existence check (e.g., \"skillTags\" or \"projects\")\n    if (parts.length === 1) {\n      if (expertValue == null) return false;\n      \n      if (Array.isArray(expertValue)) {\n        const result = expertValue.length > 0;\n        this.log(`Existence check on array '${field}': length is ${expertValue.length}, result: ${result}`);\n        return result;\n      }\n      \n      const result = !!expertValue;\n      this.log(`Existence check on field '${field}': value is ${expertValue}, result: ${result}`);\n      return result;\n    }\n    \n    if (expertValue == null) {\n      this.log(`Field '${field}' is null/undefined, condition fails`);\n      return false;\n    }\n    \n    const restOfCondition = parts.slice(1).join(':'); // Handle colons in values\n    this.log(`Evaluating condition: ${field} (${expertValue}, type: ${typeof expertValue}) against ${restOfCondition}`);\n    \n    // Check for comparison operators\n    if (restOfCondition.startsWith('>=')) {\n      const value = restOfCondition.substring(2);\n      const result = Number(expertValue) >= Number(value);\n      this.log(`Comparison: ${expertValue} >= ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('<=')) {\n      const value = restOfCondition.substring(2);\n      const result = Number(expertValue) <= Number(value);\n      this.log(`Comparison: ${expertValue} <= ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('>')) {\n      const value = restOfCondition.substring(1);\n      const result = Number(expertValue) > Number(value);\n      this.log(`Comparison: ${expertValue} > ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('<')) {\n      const value = restOfCondition.substring(1);\n      const result = Number(expertValue) < Number(value);\n      this.log(`Comparison: ${expertValue} < ${value} = ${result}`);\n      return result;\n    } else {\n      // Direct value comparison with type-aware handling\n      let result = false;\n      \n      // Handle boolean fields specially\n      if (typeof expertValue === 'boolean') {\n        // Convert string condition to boolean for comparison\n        if (restOfCondition.toLowerCase() === 'true') {\n          result = expertValue === true;\n        } else if (restOfCondition.toLowerCase() === 'false') {\n          result = expertValue === false;\n        } else {\n          result = false;\n        }\n        this.log(`Boolean comparison: ${expertValue} === ${restOfCondition.toLowerCase() === 'true'} = ${result}`);\n      } else if (typeof expertValue === 'number') {\n        // Handle numeric comparisons\n        const numValue = Number(restOfCondition);\n        result = !isNaN(numValue) && expertValue === numValue;\n        this.log(`Number comparison: ${expertValue} === ${numValue} = ${result}`);\n      } else {\n        // String comparison (case-insensitive)\n        const expertStr = String(expertValue);\n        const valueStr = String(restOfCondition);\n        result = expertStr.toLowerCase() === valueStr.toLowerCase();\n        this.log(`String comparison: '${expertStr}' === '${valueStr}' = ${result}`);\n      }\n      \n      return result;\n    }\n  }\n\n  /**\n   * Update UI states based on current data\n   */\n  private updateUIStates(container: Element, programId: string): void {\n    const state = this.state.getState(programId);\n    \n    // Show/hide empty state\n    const emptyElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.empty}]`);\n    if (emptyElement) {\n      (emptyElement as HTMLElement).style.display = state.experts.length === 0 ? '' : 'none';\n    }\n    \n    // Update pagination info\n    const paginationElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationElements.forEach(element => {\n      const { currentPage, totalCount } = state;\n      const pageSize = state.filters.limit || 20;\n      const totalPages = Math.ceil(totalCount / pageSize);\n      \n      element.textContent = `Page ${currentPage} of ${totalPages} (${totalCount} total)`;\n    });\n    \n    // Update filter summaries\n    const filterSummaries = this.querySelectorAll(container, '[data-contra-filter-summary]');\n    filterSummaries.forEach(element => {\n      const activeFilters = Object.entries(state.filters)\n        .filter(([_key, value]) => value != null && value !== '')\n        .map(([key, value]) => `${key}: ${value}`)\n        .join(', ');\n      \n      element.textContent = activeFilters || 'No filters applied';\n    });\n  }\n\n  /**\n   * Handle action buttons with proper pagination logic\n   */\n  private handleAction(containerId: string, action: string, _target?: string | null, button?: Element): void {\n    const state = this.state.getState(containerId);\n    const container = document.querySelector(`[data-container-id=\"${containerId}\"]`);\n    \n    if (!container) {\n      this.log(`Container not found: ${containerId}`);\n      return;\n    }\n\n    // Show button feedback\n    if (button && button instanceof HTMLButtonElement) {\n      button.disabled = true;\n    }\n    \n    const limit = state.filters.limit || 20;\n    const currentOffset = state.filters.offset || 0;\n    \n    switch (action) {\n      case 'next-page':\n        if (state.paginationMode === 'traditional') {\n          const nextOffset = currentOffset + limit;\n          if (nextOffset < state.totalCount) {\n            this.updateFilter(containerId, 'offset', nextOffset);\n            this.loadExperts(container as Element, containerId, true);\n          }\n        } else {\n          // For infinite mode, use load more functionality\n          this.loadMoreExperts(container as Element, containerId);\n        }\n        break;\n        \n      case 'prev-page':\n        if (state.paginationMode === 'traditional') {\n          const prevOffset = Math.max(0, currentOffset - limit);\n          this.updateFilter(containerId, 'offset', prevOffset);\n          this.loadExperts(container as Element, containerId, true);\n        }\n        break;\n        \n      case 'first-page':\n        if (state.paginationMode === 'traditional') {\n          this.updateFilter(containerId, 'offset', 0);\n          this.loadExperts(container as Element, containerId, true);\n        }\n        break;\n        \n      case 'last-page':\n        if (state.paginationMode === 'traditional') {\n          const totalPages = Math.ceil(state.totalCount / limit);\n          const lastPageOffset = (totalPages - 1) * limit;\n          this.updateFilter(containerId, 'offset', lastPageOffset);\n          this.loadExperts(container as Element, containerId, true);\n        }\n        break;\n        \n      case 'load-more':\n        // Handle load more for infinite/hybrid modes\n        this.loadMoreExperts(container as Element, containerId).finally(() => {\n          if (button && button instanceof HTMLButtonElement) {\n            button.disabled = false;\n          }\n        });\n        return; // Exit early to avoid re-enabling button\n        \n      case 'reload':\n        // Clear cache and reload\n        this.state.updateState(containerId, { cachedPages: new Map() });\n        this.loadExperts(container as Element, containerId);\n        break;\n    }\n    \n    // Re-enable button after action completes\n    if (button && button instanceof HTMLButtonElement && action !== 'load-more') {\n      setTimeout(() => {\n        button.disabled = false;\n      }, 100);\n    }\n  }\n\n  /**\n   * Load more experts for infinite scroll mode\n   */\n  private async loadMoreExperts(container: Element, programId: string): Promise<void> {\n    const state = this.state.getState(programId);\n    \n    // Only allow load more for infinite/hybrid modes\n    if (state.paginationMode === 'traditional') {\n      this.log('Load more not supported in traditional pagination mode');\n      return;\n    }\n    \n    const limit = state.filters.limit || 20;\n    \n    // Calculate next offset based on currently loaded experts\n    const currentOffset = state.experts.length;\n    \n    this.log(`Loading more experts: currentOffset=${currentOffset}, limit=${limit}`);\n\n    try {\n      this.state.updateState(programId, { isInfiniteLoading: true });\n      this.updateLoadMoreButtonState(container, programId, true);\n\n      // Fetch next batch using current expert count as offset\n      const response = await this.client.listExperts(programId, {\n        ...state.filters,\n        offset: currentOffset,\n        limit: limit\n      });\n\n      this.log(`Loaded ${response.data.length} more experts from offset ${currentOffset}`);\n\n      // Handle the response using the infinite pagination handler\n      this.handleInfinitePaginationResponse(programId, container, response);\n\n    } catch (error) {\n      this.log(`Failed to load more experts`, error);\n      this.state.updateState(programId, { isInfiniteLoading: false });\n      \n      // Show error in load more button\n      this.updateLoadMoreButtonState(container, programId, false, 'Error loading more');\n      \n      setTimeout(() => {\n        this.updateLoadMoreButtonState(container, programId, false);\n      }, 3000);\n    } finally {\n      this.updateLoadMoreButtonState(container, programId, false);\n    }\n  }\n\n  /**\n   * Update load more button state\n   */\n  private updateLoadMoreButtonState(container: Element, programId: string, loading: boolean, errorText?: string): void {\n    const loadMoreButtons = this.querySelectorAll(container, '[data-contra-action=\"load-more\"]');\n    const state = this.state.getState(programId);\n    \n    loadMoreButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      \n      if (errorText) {\n        btnElement.textContent = errorText;\n        btnElement.disabled = true;\n        btnElement.classList.add('error');\n        return;\n      }\n      \n      btnElement.classList.remove('error');\n      \n      if (loading) {\n        btnElement.textContent = 'Loading...';\n        btnElement.disabled = true;\n        btnElement.classList.add('loading');\n      } else {\n        btnElement.classList.remove('loading');\n        const hasMore = state.experts.length < state.totalCount;\n        \n        if (hasMore) {\n          btnElement.textContent = this.config.loadMoreText;\n          btnElement.disabled = false;\n        } else {\n          btnElement.textContent = 'All experts loaded';\n          btnElement.disabled = true;\n          btnElement.classList.add('disabled');\n        }\n      }\n    });\n  }\n\n  /**\n   * Load next page for infinite scroll\n   */\n  private async loadNextPageInfinite(container: Element, programId: string): Promise<void> {\n    // Use the unified loadMoreExperts method\n    return this.loadMoreExperts(container, programId);\n  }\n\n  /**\n   * Update pagination control states based on current mode and state\n   */\n  private updatePaginationControls(container: Element, programId: string): void {\n    const state = this.state.getState(programId);\n    const limit = state.filters.limit || 20;\n    const totalPages = Math.ceil(state.totalCount / limit);\n    \n    if (state.paginationMode === 'traditional') {\n      this.updateTraditionalPaginationControls(container, state, totalPages);\n    } else {\n      this.updateInfinitePaginationControls(container, state);\n    }\n\n    this.log(`Pagination controls updated: mode=${state.paginationMode}, page=${state.currentPage}/${totalPages}, hasNext=${state.hasNextPage}`);\n  }\n\n  /**\n   * Update traditional pagination controls (Previous/Next buttons, page numbers)\n   */\n  private updateTraditionalPaginationControls(container: Element, state: any, totalPages: number): void {\n    // Update navigation buttons\n    const prevButtons = this.querySelectorAll(container, '[data-contra-action=\"prev-page\"]');\n    const nextButtons = this.querySelectorAll(container, '[data-contra-action=\"next-page\"]');\n    const firstButtons = this.querySelectorAll(container, '[data-contra-action=\"first-page\"]');\n    const lastButtons = this.querySelectorAll(container, '[data-contra-action=\"last-page\"]');\n\n    // Previous page buttons\n    prevButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = !state.hasPreviousPage;\n      btnElement.classList.toggle('disabled', !state.hasPreviousPage);\n    });\n\n    // Next page buttons\n    nextButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = !state.hasNextPage;\n      btnElement.classList.toggle('disabled', !state.hasNextPage);\n    });\n\n    // First page buttons\n    firstButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = state.currentPage <= 1;\n      btnElement.classList.toggle('disabled', state.currentPage <= 1);\n    });\n\n    // Last page buttons\n    lastButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = state.currentPage >= totalPages;\n      btnElement.classList.toggle('disabled', state.currentPage >= totalPages);\n    });\n\n    // Update pagination info elements\n    const paginationInfoElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationInfoElements.forEach(element => {\n      if (state.totalCount > 0) {\n        element.textContent = `Page ${state.currentPage} of ${totalPages} (${state.totalCount} total experts)`;\n      } else {\n        element.textContent = 'No experts found.';\n      }\n    });\n\n    // --- FIX: Show pagination controls if there are ANY results, not just if there's more than one page.\n    const paginationSections = this.querySelectorAll(container, '.pagination-section');\n    this.log(`Updating pagination visibility. Total Pages: ${totalPages}, Total Count: ${state.totalCount}`);\n    paginationSections.forEach(section => {\n      // The old logic `totalPages > 1` was hiding the controls undesirably.\n      // The new logic shows the controls as long as there's something to show.\n      (section as HTMLElement).style.display = state.totalCount > 0 ? '' : 'none';\n    });\n  }\n\n  /**\n   * Update infinite pagination controls (Load More button)\n   */\n  private updateInfinitePaginationControls(container: Element, state: any): void {\n    // Update load more buttons\n    this.updateLoadMoreButtonState(container, state.programId || 'default', state.isInfiniteLoading);\n\n    // Update pagination info elements for infinite mode\n    const paginationInfoElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationInfoElements.forEach(element => {\n      const loadedCount = state.experts.length;\n      const totalCount = state.totalCount;\n      element.textContent = `Showing ${loadedCount} of ${totalCount} experts`;\n    });\n\n    // Hide traditional pagination controls in infinite mode\n    const paginationControls = container.querySelector('.pagination-controls');\n    if (paginationControls) {\n      (paginationControls as HTMLElement).style.display = 'none';\n    }\n  }\n\n  /**\n   * Update infinite loading state\n   */\n  private updateInfiniteLoadingState(container: Element, loading: boolean): void {\n    const loadingIndicators = this.querySelectorAll(container, '[data-contra-infinite-loading]');\n    \n    loadingIndicators.forEach(indicator => {\n      (indicator as HTMLElement).style.display = loading ? '' : 'none';\n    });\n  }\n\n  /**\n   * Render new experts for infinite scroll (append mode)\n   */\n  private renderNewExperts(container: Element, newExperts: ExpertProfile[]): void {\n    // Look for template in the container or its expert-grid child\n    let template = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.template}]`);\n    let targetContainer = container;\n    \n    // If template not found directly, look in expert-grid child\n    if (!template) {\n      const expertGrid = this.querySelector(container, '.expert-grid');\n      if (expertGrid) {\n        template = this.querySelector(expertGrid, `[${ATTR_PREFIX}${ATTRS.template}]`);\n        targetContainer = expertGrid;\n      }\n    }\n    \n    if (!template) {\n      this.log('No template found for rendering new experts', container);\n      return;\n    }\n\n    // Create a document fragment for efficient DOM manipulation\n    const fragment = document.createDocumentFragment();\n\n    newExperts.forEach(expert => {\n      const expertCard = this.populateExpertCard(template, expert);\n      fragment.appendChild(expertCard);\n    });\n\n    // Append all new cards at once\n    targetContainer.appendChild(fragment);\n\n    this.log(`Rendered ${newExperts.length} new expert cards for load more`);\n  }\n\n  // ... (utility methods continue below)\n\n  /**\n   * Utility Methods\n   */\n  private getAttr(element: Element, name: string): string | null {\n    return element.getAttribute(`${ATTR_PREFIX}${name}`);\n  }\n\n  private querySelector(element: Element, selector: string): Element | null {\n    return element.querySelector(selector);\n  }\n\n  private querySelectorAll(element: Element, selector: string): Element[] {\n    return Array.from(element.querySelectorAll(selector));\n  }\n\n  private findExpertContainers(): Element[] {\n    this.log('Looking for expert containers...');\n    \n    // A container is DEFINED by having a limit or pagination attribute.\n    // This is the most reliable way to find the top-level component boundaries.\n    const selector = `[${ATTR_PREFIX}${ATTRS.limit}], [${ATTR_PREFIX}${ATTRS.paginationMode}]`;\n    const containers = Array.from(document.querySelectorAll(selector));\n    \n    this.log(`Found ${containers.length} containers using selector: ${selector}`, containers);\n    return containers;\n  }\n\n  private parseFiltersFromElement(element: Element): ExpertFilters {\n    const filters: ExpertFilters = {};\n    \n    // Parse filter attributes\n    const filterMap = {\n      'available': 'available',\n      'languages': 'languages', \n      'location': 'location',\n      'min-rate': 'minRate',\n      'max-rate': 'maxRate',\n      'sort': 'sortBy',\n      'limit': 'limit',\n      'offset': 'offset'\n    };\n\n    Object.entries(filterMap).forEach(([attr, filterKey]) => {\n      const value = this.getAttr(element, attr);\n      if (value != null) {\n        if (filterKey === 'available') {\n          (filters as any)[filterKey] = value === 'true';\n        } else if (filterKey === 'languages') {\n          (filters as any)[filterKey] = value.split(',').map(v => v.trim());\n        } else if (['minRate', 'maxRate', 'limit', 'offset'].includes(filterKey)) {\n          (filters as any)[filterKey] = parseInt(value);\n        } else {\n          (filters as any)[filterKey] = value;\n        }\n      }\n    });\n\n    // Ensure offset defaults to 0 if not specified\n    if (filters.offset === undefined) {\n      filters.offset = 0;\n    }\n\n    return filters;\n  }\n\n  private getControlValue(control: HTMLInputElement | HTMLSelectElement): any {\n    if (control instanceof HTMLInputElement) {\n      switch (control.type) {\n        case 'checkbox':\n          return control.checked;\n        case 'number':\n        case 'range':\n          return control.valueAsNumber;\n        default:\n          return control.value;\n      }\n    } else if (control instanceof HTMLSelectElement) {\n      if (control.multiple) {\n        return Array.from(control.selectedOptions).map(option => option.value);\n      }\n      return control.value;\n    }\n    return null;\n  }\n\n  private updateFilter(programId: string, filterKey: string, value: any, type: string = 'replace'): void {\n    const state = this.state.getState(programId);\n    const newFilters = { ...state.filters };\n\n    // Handle special cases for filter value conversion to match OpenAPI spec (expects strings)\n    let processedValue: string | number | undefined = value;\n    \n    // Convert all values to strings, unless they are numbers for limit/offset.\n    // Handle empty/null values by setting them to undefined so they are omitted from the request.\n    if (value === null || value === '') {\n      processedValue = undefined;\n    } else if (typeof value === 'boolean') {\n      processedValue = String(value); // \"true\" or \"false\"\n    } else if (typeof value === 'number' && !['limit', 'offset', 'minRate', 'maxRate'].includes(filterKey)) {\n      processedValue = String(value);\n    }\n\n    if (type === 'append' && Array.isArray(newFilters[filterKey as keyof ExpertFilters])) {\n      const currentArray = newFilters[filterKey as keyof ExpertFilters] as any[];\n      (newFilters[filterKey as keyof ExpertFilters] as any) = [...currentArray, processedValue];\n    } else {\n      (newFilters as any)[filterKey] = processedValue;\n    }\n\n    // Reset offset to 0 when any filter changes (except offset itself)\n    // This ensures we start from the beginning when filters change\n    if (filterKey !== 'offset') {\n      newFilters.offset = 0;\n    }\n\n    // Remove keys with undefined values\n    Object.keys(newFilters).forEach(key => {\n      if ((newFilters as any)[key] === undefined) {\n        delete (newFilters as any)[key];\n      }\n    });\n\n    this.state.updateState(programId, { filters: newFilters });\n    \n    this.log(`Filter updated: ${filterKey} = ${processedValue} (final filters: `, newFilters, ')');\n    \n    // Dispatch filter change event\n    const event: FilterChangeEvent = {\n      filters: newFilters,\n      element: document.querySelector(`[data-container-id=\"${programId}\"]`) as HTMLElement\n    };\n    \n    this.dispatchEvent(document as any, 'filterChange', event);\n  }\n\n  private showLoading(container: Element, show: boolean): void {\n    const loadingElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.loading}]`);\n    if (loadingElement) {\n      (loadingElement as HTMLElement).style.display = show ? '' : 'none';\n    }\n    \n    (container as HTMLElement).classList.toggle(this.config.loadingClass, show);\n  }\n\n  private showError(container: Element, error: Error): void {\n    const errorElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.error}]`);\n    if (errorElement) {\n      errorElement.textContent = error.message;\n      (errorElement as HTMLElement).style.display = '';\n    }\n    \n    (container as HTMLElement).classList.add(this.config.errorClass);\n    this.log('Error displayed', error);\n  }\n\n  private dispatchEvent(target: Element | Document, eventName: string, detail: any): void {\n    const event = new CustomEvent(`contra:${eventName}`, { detail });\n    target.dispatchEvent(event);\n  }\n\n  private log(message: string, ...args: any[]): void {\n    if (this.config.debug) {\n      console.log(`[ContraWebflow] ${message}`, ...args);\n    }\n  }\n}\n\n/**\n * Auto-initialize runtime when DOM is ready\n */\nfunction autoInit(): void {\n  const configElement = document.getElementById('contra-config');\n  if (!configElement) {\n    console.warn('[ContraWebflow] No config element found. Runtime not initialized.');\n    return;\n  }\n\n  try {\n    const config = JSON.parse(configElement.textContent || '{}');\n    \n    // Validate required config\n    if (!config.apiKey) {\n      console.error('[ContraWebflow] API key is required in config.');\n      return;\n    }\n    \n    if (!config.program) {\n      console.error('[ContraWebflow] Program ID is required in config.');\n      return;\n    }\n    \n    // Add a small delay to ensure all DOM elements are ready\n    const initializeRuntime = () => {\n      const runtime = new ContraWebflowRuntime(config);\n      \n      // Expose runtime globally for debugging\n      (window as any).contraRuntime = runtime;\n      \n      runtime.init().catch(error => {\n        console.error('[ContraWebflow] Runtime initialization failed:', error);\n      });\n    };\n    \n    // Use setTimeout to ensure DOM is fully ready\n    setTimeout(initializeRuntime, 100);\n    \n  } catch (error) {\n    console.error('[ContraWebflow] Failed to parse config:', error);\n  }\n}\n\n// Auto-initialize when DOM is ready with multiple fallbacks\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else if (document.readyState === 'interactive') {\n  // DOM is ready but resources might still be loading\n  setTimeout(autoInit, 50);\n} else {\n  // DOM and resources are ready\n  autoInit();\n}\n\n// Export runtime class for manual initialization\nexport { ContraWebflowRuntime as default }; ","import type {\n  ClientConfig,\n  ExpertProfile,\n  ExpertFilters,\n  ProgramSummary,\n  ListResponse,\n  ApiResponse,\n  ErrorResponse,\n  Filter,\n  FilterListResponse\n} from '@contra/types';\n\n/**\n * Professional Contra API Client\n * Features: Caching, retry logic, error handling, request deduplication\n */\nexport class ContraClient {\n  private config: Required<ClientConfig>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n  private pendingRequests = new Map<string, Promise<any>>();\n  \n  // Cache TTL settings (in milliseconds)\n  private static readonly CACHE_TTL = {\n    experts: 5 * 60 * 1000,      // 5 minutes for expert lists\n    expert: 10 * 60 * 1000,     // 10 minutes for individual experts\n    program: 30 * 60 * 1000,    // 30 minutes for program info\n    filters: 60 * 60 * 1000,    // 1 hour for available filters\n  };\n\n  constructor(config: ClientConfig) {\n    this.config = {\n      baseUrl: 'https://contra.com',\n      timeout: 10000,\n      debug: false,\n      ...config,\n    };\n\n    if (this.config.debug) {\n      console.log('[ContraClient] Initialized with config:', this.config);\n    }\n  }\n\n  /**\n   * Core fetch method with retry logic and error handling\n   */\n  private async fetch<T>(\n    endpoint: string,\n    options: RequestInit = {},\n    retries = 3\n  ): Promise<T> {\n    const url = `${this.config.baseUrl}${endpoint}`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n    const requestOptions: RequestInit = {\n      ...options,\n      signal: controller.signal,\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n        'Authorization': this.config.apiKey,\n        'X-API-Key': this.config.apiKey,\n        ...options.headers,\n      },\n    };\n\n    try {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Fetching: ${url}`, requestOptions);\n      }\n\n      const response = await fetch(url, requestOptions);\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        // Try to parse error response\n        let errorData: ErrorResponse;\n        try {\n          errorData = await response.json();\n        } catch {\n          errorData = {\n            code: `HTTP_${response.status}`,\n            message: response.statusText || 'Unknown error'\n          };\n        }\n\n        // Retry on 5xx errors or rate limits\n        if ((response.status >= 500 || response.status === 429) && retries > 0) {\n          const delay = Math.pow(2, 3 - retries) * 1000; // Exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return this.fetch<T>(endpoint, options, retries - 1);\n        }\n\n        throw new ContraAPIError(errorData.message, errorData.code, response.status);\n      }\n\n      const data = await response.json();\n      \n      if (this.config.debug) {\n        console.log(`[ContraClient] Response:`, data);\n      }\n\n      return data;\n\n    } catch (error) {\n      clearTimeout(timeoutId);\n      \n      if (error instanceof ContraAPIError) {\n        throw error;\n      }\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new ContraAPIError(`Request timeout after ${this.config.timeout}ms`, 'TIMEOUT');\n      }\n\n      // Network or other errors - retry if we have retries left\n      if (retries > 0) {\n        const delay = Math.pow(2, 3 - retries) * 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.fetch<T>(endpoint, options, retries - 1);\n      }\n\n      throw new ContraAPIError(\n        error instanceof Error ? error.message : 'Unknown error',\n        'NETWORK_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Get from cache or fetch with request deduplication\n   */\n  private async fetchWithCache<T>(\n    cacheKey: string,\n    endpoint: string,\n    ttl: number,\n    options?: RequestInit\n  ): Promise<T> {\n    // Check cache first\n    const cached = this.cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < cached.ttl) {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Cache hit: ${cacheKey}`);\n      }\n      return cached.data;\n    }\n\n    // Check for pending request (deduplication)\n    const pendingKey = `${endpoint}${JSON.stringify(options)}`;\n    if (this.pendingRequests.has(pendingKey)) {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Request deduplication: ${pendingKey}`);\n      }\n      return this.pendingRequests.get(pendingKey)!;\n    }\n\n    // Make the request\n    const requestPromise = this.fetch<T>(endpoint, options);\n    this.pendingRequests.set(pendingKey, requestPromise);\n\n    try {\n      const data = await requestPromise;\n      \n      // Cache the result\n      this.cache.set(cacheKey, {\n        data,\n        timestamp: Date.now(),\n        ttl\n      });\n\n      return data;\n    } finally {\n      this.pendingRequests.delete(pendingKey);\n    }\n  }\n\n  /**\n   * Build query string from filters\n   */\n  private buildQueryString(filters: ExpertFilters): string {\n    const params = new URLSearchParams();\n    \n    Object.entries(filters).forEach(([key, value]) => {\n      if (value != null && value !== '') {\n        if (Array.isArray(value)) {\n          params.set(key, value.join(','));\n        } else {\n          params.set(key, String(value));\n        }\n      }\n    });\n\n    const queryString = params.toString();\n    return queryString ? `?${queryString}` : '';\n  }\n\n  /**\n   * Get program information\n   */\n  async getProgram(programNid: string): Promise<ProgramSummary> {\n    const cacheKey = `program:${programNid}`;\n    const endpoint = `/public-api/programs/${programNid}`;\n    \n    const response = await this.fetchWithCache<ApiResponse<ProgramSummary>>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.program\n    );\n    \n    return response.data;\n  }\n\n  /**\n   * List experts with advanced filtering and caching\n   */\n  async listExperts(\n    programNid: string,\n    filters: ExpertFilters = {}\n  ): Promise<ListResponse<ExpertProfile>> {\n    const queryString = this.buildQueryString(filters);\n    const cacheKey = `experts:${programNid}:${JSON.stringify(filters)}`;\n    const endpoint = `/public-api/programs/${programNid}/experts${queryString}`;\n    \n    return this.fetchWithCache<ListResponse<ExpertProfile>>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.experts\n    );\n  }\n\n  /**\n   * Search experts (using the main experts endpoint with filters)\n   */\n  async searchExperts(\n    programNid: string,\n    query: string,\n    filters: ExpertFilters = {}\n  ): Promise<ListResponse<ExpertProfile>> {\n    // Search is handled by client-side filtering since API doesn't support text search\n    const experts = await this.listExperts(programNid, filters);\n    \n    // Client-side filtering for search (since API doesn't support text search)\n    if (query.trim()) {\n      const searchTerm = query.toLowerCase();\n      experts.data = experts.data.filter(expert => \n        (expert.name && expert.name.toLowerCase().includes(searchTerm)) ||\n        (expert.oneLiner && expert.oneLiner.toLowerCase().includes(searchTerm)) ||\n        (expert.skillTags && expert.skillTags.some(tag => tag && tag.toLowerCase().includes(searchTerm)))\n      );\n    }\n    \n    return experts;\n  }\n\n  /**\n   * Get available filter options for a program\n   */\n  async getFilterOptions(programNid: string): Promise<FilterListResponse> {\n    const cacheKey = `filters:${programNid}`;\n    const endpoint = `/public-api/programs/${programNid}/filters`;\n    \n    return this.fetchWithCache<FilterListResponse>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.filters\n    );\n  }\n\n  /**\n   * Clear cache (useful for forced refreshes)\n   */\n  clearCache(pattern?: string): void {\n    if (pattern) {\n      // Clear specific cache entries\n      for (const key of this.cache.keys()) {\n        if (key.includes(pattern)) {\n          this.cache.delete(key);\n        }\n      }\n    } else {\n      // Clear all cache\n      this.cache.clear();\n    }\n\n    if (this.config.debug) {\n      console.log(`[ContraClient] Cache cleared${pattern ? ` (pattern: ${pattern})` : ''}`);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): {\n    size: number;\n    entries: Array<{ key: string; age: number; ttl: number }>;\n  } {\n    const now = Date.now();\n    const entries = Array.from(this.cache.entries()).map(([key, value]) => ({\n      key,\n      age: now - value.timestamp,\n      ttl: value.ttl\n    }));\n\n    return {\n      size: this.cache.size,\n      entries\n    };\n  }\n}\n\n/**\n * Custom error class for API errors\n */\nexport class ContraAPIError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public status?: number\n  ) {\n    super(message);\n    this.name = 'ContraAPIError';\n  }\n}\n\n/**\n * Utility functions\n */\nexport const utils = {\n  /**\n   * Format hourly rate with proper handling of null values\n   */\n  formatRate(rate: number | null): string {\n    return rate ? `$${rate}/hr` : 'Rate on request';\n  },\n\n  /**\n   * Generate star rating HTML\n   */\n  renderStars(rating: number): string {\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = (rating % 1) >= 0.5;\n    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);\n    \n    let html = '';\n    \n    // Full stars\n    for (let i = 0; i < fullStars; i++) {\n      html += `<svg class=\"star star-full\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"#FFD700\">\n        <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    // Half star\n    if (hasHalfStar) {\n      html += `<svg class=\"star star-half\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\n        <defs>\n          <linearGradient id=\"half-${rating}\">\n            <stop offset=\"50%\" stop-color=\"#FFD700\"/>\n            <stop offset=\"50%\" stop-color=\"#E5E5E5\"/>\n          </linearGradient>\n        </defs>\n        <path fill=\"url(#half-${rating})\" d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    // Empty stars\n    for (let i = 0; i < emptyStars; i++) {\n      html += `<svg class=\"star star-empty\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"#E5E5E5\">\n        <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    return html;\n  },\n\n  /**\n   * Debounce function for search inputs\n   */\n  debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait: number\n  ): (...args: Parameters<T>) => void {\n    let timeout: NodeJS.Timeout;\n    return (...args: Parameters<T>) => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func(...args), wait);\n    };\n  },\n\n  /**\n   * Throttle function for scroll events\n   */\n  throttle<T extends (...args: any[]) => any>(\n    func: T,\n    limit: number\n  ): (...args: Parameters<T>) => void {\n    let inThrottle: boolean;\n    return (...args: Parameters<T>) => {\n      if (!inThrottle) {\n        func(...args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n}; "],"mappings":"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","names":["runtime_exports","__export","ContraWebflowRuntime","_ContraClient","config","endpoint","options","retries","url","controller","timeoutId","requestOptions","response","errorData","delay","resolve","ContraAPIError","data","error","cacheKey","ttl","cached","pendingKey","requestPromise","filters","params","key","value","queryString","programNid","query","experts","searchTerm","expert","tag","pattern","now","entries","ContraClient","message","code","status","utils","rate","rating","fullStars","hasHalfStar","emptyStars","html","i","func","wait","timeout","args","limit","inThrottle","ATTR_PREFIX","ATTRS","RuntimeState","programId","updates","state","pageNumber","experts","oldestPage","loading","ContraWebflowRuntime","config","f","allContainers","containers","container","error","containerId","timeout","element","paginationMode","limit","filterControls","control","filterKey","filterType","eventType","button","action","target","e","isPageNavigation","response","offset","currentPage","totalPages","hasNextPage","hasPreviousPage","isLoadMore","allExperts","filters","totalCount","template","targetContainer","expertGrid","card","expert","expertCard","fieldName","format","value","displayValue","d","rating","fullStars","hasHalfStar","emptyStars","starsHtml","i","textElement","url","mediaType","parent","mediaElement","urlLower","isVideo","ext","isCloudinaryVideo","originalElement","video","posterUrl","fallbackImg","img","placeholder","videoUrl","from","to","attr","existingStyle","repeatType","maxItems","tag","items","item","itemElement","showWhen","hideWhen","shouldShow","condition","parts","field","expertValue","result","restOfCondition","numValue","expertStr","valueStr","emptyElement","pageSize","activeFilters","_key","key","_target","currentOffset","nextOffset","prevOffset","lastPageOffset","errorText","loadMoreButtons","btnElement","prevButtons","nextButtons","firstButtons","lastButtons","paginationSections","section","loadedCount","paginationControls","indicator","newExperts","fragment","name","selector","v","option","type","newFilters","processedValue","currentArray","event","show","loadingElement","errorElement","eventName","detail","message","args","autoInit","configElement","runtime"]}