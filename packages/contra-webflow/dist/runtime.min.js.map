{"version":3,"sources":["../src/runtime.ts","../../contra-client/src/client.ts"],"sourcesContent":["import { ContraClient, utils } from '@contra/client';\nimport type {\n  ExpertProfile,\n  ExpertFilters,\n  FilterChangeEvent,\n  ExpertLoadEvent,\n  ErrorEvent,\n  ExpertField\n} from '@contra/types';\n\n/**\n * Webflow Runtime for Contra Experts\n * Features: Performance optimization, filtering, error handling, loading states\n */\n\n// Configuration interface\ninterface RuntimeConfig {\n  apiKey: string;\n  debug?: boolean;\n  loadingClass?: string;\n  errorClass?: string;\n  emptyClass?: string;\n  autoReload?: boolean;\n  debounceDelay?: number;\n  maxRetries?: number;\n  \n  // Pagination Configuration\n  paginationMode?: 'traditional' | 'infinite' | 'hybrid';\n  infiniteScrollThreshold?: number;        // Pixels from bottom to trigger load\n  preloadNextPage?: boolean;              // Preload next page for performance\n  maxCachedPages?: number;                // Max pages to keep in memory\n  smoothScrollBehavior?: 'auto' | 'smooth';\n  loadMoreText?: string;                  // Custom \"Load More\" button text\n  \n  // Video configuration\n  videoAutoplay?: boolean;\n  videoHoverPlay?: boolean;\n  videoMuted?: boolean;\n  videoLoop?: boolean;\n  videoControls?: boolean;\n}\n\n// Attribute constants\nconst ATTR_PREFIX = 'data-contra-';\nconst ATTRS = {\n  // Core attributes\n  program: 'program',\n  template: 'template',\n  loading: 'loading',\n  error: 'error',\n  empty: 'empty',\n  \n  // Field binding\n  field: 'field',\n  format: 'format',\n  \n  // Repeating elements\n  repeat: 'repeat',\n  max: 'max',\n  \n  // Filter controls\n  filter: 'filter',\n  filterType: 'filter-type',\n  \n  // Filter attributes\n  available: 'available',\n  \n  // Sorting and pagination\n  sort: 'sort',\n  page: 'page',\n  limit: 'limit',\n  \n  // Pagination mode and controls\n  paginationMode: 'pagination-mode',\n  infiniteLoading: 'infinite-loading',\n  paginationInfo: 'pagination-info',\n  \n  // UI states\n  showWhen: 'show-when',\n  hideWhen: 'hide-when',\n  \n  // Actions\n  action: 'action',\n  target: 'target'\n} as const;\n\n// State management\nclass RuntimeState {\n  private states = new Map<string, {\n    filters: ExpertFilters;\n    experts: ExpertProfile[];\n    loading: boolean;\n    error: Error | null;\n    currentPage: number;\n    totalCount: number;\n    // Advanced pagination state\n    cachedPages: Map<number, ExpertProfile[]>;\n    loadingPages: Set<number>;\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n    isInfiniteLoading: boolean;\n    lastScrollPosition: number;\n    paginationMode: 'traditional' | 'infinite' | 'hybrid';\n  }>();\n\n  getState(programId: string) {\n    if (!this.states.has(programId)) {\n      this.states.set(programId, {\n        filters: {},\n        experts: [],\n        loading: false,\n        error: null,\n        currentPage: 1,\n        totalCount: 0,\n        // Advanced pagination defaults\n        cachedPages: new Map(),\n        loadingPages: new Set(),\n        hasNextPage: false,\n        hasPreviousPage: false,\n        isInfiniteLoading: false,\n        lastScrollPosition: 0,\n        paginationMode: 'traditional'\n      });\n    }\n    return this.states.get(programId)!;\n  }\n\n  updateState(programId: string, updates: Partial<ReturnType<RuntimeState['getState']>>) {\n    const state = this.getState(programId);\n    Object.assign(state, updates);\n    this.states.set(programId, state);\n  }\n\n  // Advanced pagination helpers\n  cachePage(programId: string, pageNumber: number, experts: ExpertProfile[]) {\n    const state = this.getState(programId);\n    state.cachedPages.set(pageNumber, experts);\n    \n    // Implement LRU cache cleanup\n    if (state.cachedPages.size > 5) { // maxCachedPages from config\n      const oldestPage = Math.min(...state.cachedPages.keys());\n      state.cachedPages.delete(oldestPage);\n    }\n  }\n\n  getCachedPage(programId: string, pageNumber: number): ExpertProfile[] | null {\n    const state = this.getState(programId);\n    return state.cachedPages.get(pageNumber) || null;\n  }\n\n  setPageLoading(programId: string, pageNumber: number, loading: boolean) {\n    const state = this.getState(programId);\n    if (loading) {\n      state.loadingPages.add(pageNumber);\n    } else {\n      state.loadingPages.delete(pageNumber);\n    }\n  }\n\n  isPageLoading(programId: string, pageNumber: number): boolean {\n    const state = this.getState(programId);\n    return state.loadingPages.has(pageNumber);\n  }\n}\n\n/**\n * Main Runtime Class\n */\nexport class ContraWebflowRuntime {\n  private client: ContraClient;\n  private config: Required<RuntimeConfig>;\n  private state = new RuntimeState();\n  private debouncedReload: Map<string, () => void> = new Map();\n\n  constructor(config: RuntimeConfig) {\n    this.config = {\n      debug: false,\n      loadingClass: 'loading',\n      errorClass: 'error',\n      emptyClass: 'empty',\n      autoReload: true,\n      debounceDelay: 300,\n      maxRetries: 3,\n      // Pagination Configuration defaults\n      paginationMode: 'traditional',\n      infiniteScrollThreshold: 500,\n      preloadNextPage: true,\n      maxCachedPages: 5,\n      smoothScrollBehavior: 'auto',\n      loadMoreText: 'Load More',\n      // Video configuration defaults\n      videoAutoplay: false,      // No autoplay by default (better UX)\n      videoHoverPlay: true,       // Hover to play by default\n      videoMuted: true,           // Muted for autoplay compatibility\n      videoLoop: true,            // Loop videos\n      videoControls: false,       // No controls for cleaner look\n      ...config\n    };\n\n    this.client = new ContraClient({\n      apiKey: this.config.apiKey,\n      debug: this.config.debug\n    });\n\n    this.log('Runtime initialized', this.config);\n  }\n\n  /**\n   * Initialize the runtime and find all expert containers\n   */\n  async init(): Promise<void> {\n    this.log('Initializing runtime...');\n\n    try {\n      // Find all expert containers\n      const containers = this.findExpertContainers();\n      this.log(`Found ${containers.length} expert containers`);\n\n      // Initialize each container\n      for (const container of containers) {\n        await this.initContainer(container);\n      }\n\n      this.log('Runtime initialization complete');\n    } catch (error) {\n      this.log('Runtime initialization failed', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize a single expert container\n   */\n  private async initContainer(container: Element): Promise<void> {\n    const programId = this.getAttr(container, ATTRS.program);\n    if (!programId) {\n      this.log('Container missing program ID', container);\n      return;\n    }\n\n    this.log(`Initializing container for program: ${programId}`);\n\n    try {\n      // Setup container state\n      this.setupContainer(container, programId);\n      \n      // Wire up filter controls\n      this.wireFilterControls(container, programId);\n      \n      // Wire up action buttons\n      this.wireActionButtons(container, programId);\n      \n      // Load initial data\n      await this.loadExperts(container, programId);\n\n    } catch (error) {\n      this.log(`Failed to initialize container for program ${programId}`, error);\n      this.showError(container, error as Error);\n    }\n  }\n\n  /**\n   * Setup container with initial state and classes\n   */\n  private setupContainer(container: Element, programId: string): void {\n    const element = container as HTMLElement;\n    \n    // Add runtime classes\n    element.classList.add('contra-runtime');\n    element.setAttribute('data-program-id', programId);\n    \n    // Parse initial filters from attributes\n    const initialFilters = this.parseFiltersFromElement(container);\n    \n    // Determine pagination mode\n    const paginationMode = this.determinePaginationMode(container);\n    \n    this.state.updateState(programId, { \n      filters: initialFilters,\n      paginationMode: paginationMode\n    });\n    \n    // Setup pagination\n    this.setupPagination(container, programId, paginationMode);\n    \n    // Create debounced reload function\n    const debouncedReload = utils.debounce(() => {\n      this.loadExperts(container, programId);\n    }, this.config.debounceDelay);\n    \n    this.debouncedReload.set(programId, debouncedReload);\n    \n    this.log(`Container setup complete for program: ${programId}`, { initialFilters, paginationMode });\n  }\n\n  /**\n   * Determine pagination mode from container attributes or config\n   */\n  private determinePaginationMode(container: Element): 'traditional' | 'infinite' | 'hybrid' {\n    const explicitMode = this.getAttr(container, 'pagination-mode') as 'traditional' | 'infinite' | 'hybrid';\n    return explicitMode || this.config.paginationMode;\n  }\n\n  /**\n   * Setup pagination system based on mode\n   */\n  private setupPagination(container: Element, programId: string, mode: 'traditional' | 'infinite' | 'hybrid'): void {\n    this.log(`Setting up ${mode} pagination for program: ${programId}`);\n    \n    if (mode === 'infinite' || mode === 'hybrid') {\n      this.setupInfiniteScroll(container, programId);\n    }\n    \n    if (mode === 'traditional' || mode === 'hybrid') {\n      this.setupTraditionalPagination(container, programId);\n    }\n    \n    // Setup load more button for hybrid/infinite modes\n    if (mode === 'infinite' || mode === 'hybrid') {\n      this.setupLoadMoreButton(container, programId);\n    }\n  }\n\n  /**\n   * Setup infinite scroll functionality\n   */\n  private setupInfiniteScroll(container: Element, programId: string): void {\n    let isScrolling = false;\n    \n    const handleScroll = utils.throttle(() => {\n      if (isScrolling) return;\n      \n      const state = this.state.getState(programId);\n      if (state.isInfiniteLoading || !state.hasNextPage) return;\n      \n      const scrollPosition = window.scrollY + window.innerHeight;\n      const documentHeight = document.documentElement.scrollHeight;\n      const threshold = this.config.infiniteScrollThreshold;\n      \n      if (scrollPosition >= documentHeight - threshold) {\n        isScrolling = true;\n        this.loadNextPageInfinite(container, programId).finally(() => {\n          isScrolling = false;\n        });\n      }\n    }, 100);\n    \n    window.addEventListener('scroll', handleScroll);\n    \n    // Store cleanup function\n    (container as any).__infiniteScrollCleanup = () => {\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }\n\n  /**\n   * Setup traditional pagination button states\n   */\n  private setupTraditionalPagination(container: Element, programId: string): void {\n    // Will be handled in updatePaginationControls\n    this.updatePaginationControls(container, programId);\n  }\n\n  /**\n   * Setup load more button for infinite scroll\n   */\n  private setupLoadMoreButton(container: Element, programId: string): void {\n    const loadMoreButtons = this.querySelectorAll(container, '[data-contra-action=\"load-more\"]');\n    \n    loadMoreButtons.forEach(button => {\n      if (!button.textContent?.trim()) {\n        button.textContent = this.config.loadMoreText;\n      }\n    });\n  }\n\n  /**\n   * Wire up filter controls to auto-update\n   */\n  private wireFilterControls(container: Element, programId: string): void {\n    const filterControls = this.querySelectorAll(container, `[${ATTR_PREFIX}${ATTRS.filter}]`);\n    \n    this.log(`Found ${filterControls.length} filter controls for program: ${programId}`);\n\n    filterControls.forEach(control => {\n      const filterKey = this.getAttr(control, ATTRS.filter);\n      const filterType = this.getAttr(control, ATTRS.filterType) || 'replace';\n      \n      if (!filterKey) return;\n\n      // Add event listeners based on control type\n      if (control instanceof HTMLInputElement) {\n        const eventType = control.type === 'range' || control.type === 'number' ? 'input' : 'change';\n        \n        control.addEventListener(eventType, () => {\n          this.updateFilter(programId, filterKey, this.getControlValue(control), filterType);\n          if (this.config.autoReload) {\n            this.debouncedReload.get(programId)?.();\n          }\n        });\n        \n      } else if (control instanceof HTMLSelectElement) {\n        control.addEventListener('change', () => {\n          this.updateFilter(programId, filterKey, this.getControlValue(control), filterType);\n          if (this.config.autoReload) {\n            this.debouncedReload.get(programId)?.();\n          }\n        });\n      }\n      \n      this.log(`Wired filter control: ${filterKey} (${filterType})`, control);\n    });\n  }\n\n  /**\n   * Wire up action buttons (pagination, sorting, etc.)\n   */\n  private wireActionButtons(container: Element, programId: string): void {\n    const actionButtons = this.querySelectorAll(container, `[${ATTR_PREFIX}${ATTRS.action}]`);\n    \n    actionButtons.forEach(button => {\n      const action = this.getAttr(button, ATTRS.action);\n      const target = this.getAttr(button, ATTRS.target);\n      \n      if (!action) return;\n\n      button.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.handleAction(programId, action, target, button);\n      });\n    });\n  }\n\n  /**\n   * Load experts for a program\n   */\n  private async loadExperts(container: Element, programId: string, isPageNavigation = false): Promise<void> {\n    const state = this.state.getState(programId);\n    \n    this.log(`Loading experts for program: ${programId}`, state.filters);\n\n    try {\n      // Show loading state\n      this.showLoading(container, true);\n      this.state.updateState(programId, { loading: true, error: null });\n\n      // Check cache first for page navigation\n      const currentPage = Math.floor((state.filters.offset || 0) / (state.filters.limit || 20)) + 1;\n      if (isPageNavigation && state.paginationMode === 'traditional') {\n        const cachedExperts = this.state.getCachedPage(programId, currentPage);\n        if (cachedExperts) {\n          this.log(`Using cached page ${currentPage}`);\n          this.renderExperts(container, cachedExperts);\n          this.state.updateState(programId, { \n            experts: cachedExperts, \n            currentPage: currentPage,\n            loading: false \n          });\n          this.updatePaginationControls(container, programId);\n          this.showLoading(container, false);\n          return;\n        }\n      }\n\n      // Fetch experts\n      const response = await this.client.listExperts(programId, state.filters);\n      \n      this.log(`Loaded ${response.data.length} experts`, response);\n\n      // Calculate pagination state\n      const limit = state.filters.limit || 20;\n      const offset = state.filters.offset || 0;\n      const page = Math.floor(offset / limit) + 1;\n      const totalPages = Math.ceil(response.totalCount / limit);\n      const hasNextPage = page < totalPages;\n      const hasPreviousPage = page > 1;\n\n      // Update state with pagination info\n      this.state.updateState(programId, {\n        experts: response.data,\n        totalCount: response.totalCount,\n        currentPage: page,\n        hasNextPage: hasNextPage,\n        hasPreviousPage: hasPreviousPage,\n        loading: false\n      });\n\n      // Cache the page\n      this.state.cachePage(programId, page, response.data);\n\n      // Render experts\n      this.renderExperts(container, response.data);\n      \n      // Update UI states including pagination\n      this.updateUIStates(container, programId);\n      this.updatePaginationControls(container, programId);\n      \n      // Dispatch event\n      this.dispatchEvent(container, 'expertsLoaded', {\n        experts: response.data,\n        totalCount: response.totalCount,\n        filters: state.filters,\n        page: page,\n        totalPages: totalPages,\n        hasNextPage: hasNextPage,\n        hasPreviousPage: hasPreviousPage\n      } as ExpertLoadEvent);\n\n    } catch (error) {\n      this.log(`Failed to load experts for program: ${programId}`, error);\n      \n      this.state.updateState(programId, { \n        loading: false, \n        error: error as Error \n      });\n      \n      this.showError(container, error as Error);\n      \n      // Dispatch error event\n      this.dispatchEvent(container, 'expertsError', {\n        error: error as Error,\n        context: `Loading experts for program ${programId}`\n      } as ErrorEvent);\n    } finally {\n      this.showLoading(container, false);\n    }\n  }\n\n  /**\n   * Render experts into the container\n   */\n  private renderExperts(container: Element, experts: ExpertProfile[]): void {\n    const template = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.template}]`);\n    if (!template) {\n      this.log('No template found in container', container);\n      return;\n    }\n\n    // Clear existing expert cards (keep template)\n    const existingCards = this.querySelectorAll(container, ':scope > *:not([data-contra-template]):not([data-contra-loading]):not([data-contra-error]):not([data-contra-empty])');\n    existingCards.forEach(card => card.remove());\n\n    // Render expert cards\n    experts.forEach(expert => {\n      const expertCard = this.populateExpertCard(template, expert);\n      container.appendChild(expertCard);\n    });\n\n    this.log(`Rendered ${experts.length} expert cards`);\n  }\n\n  /**\n   * Populate expert card from template\n   */\n  private populateExpertCard(template: Element, expert: ExpertProfile): Element {\n    const card = template.cloneNode(true) as Element;\n    \n    // Remove template attribute and show the card\n    card.removeAttribute(`${ATTR_PREFIX}${ATTRS.template}`);\n    (card as HTMLElement).style.display = '';\n\n    // Populate field bindings\n    this.populateFields(card, expert);\n    \n    // Handle repeating elements (projects, social links)\n    this.populateRepeatingElements(card, expert);\n    \n    // Handle conditional display\n    this.handleConditionalDisplay(card, expert);\n\n    return card;\n  }\n\n  /**\n   * Populate data fields in the card\n   */\n  private populateFields(card: Element, expert: ExpertProfile): void {\n    const fieldElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.field}]`);\n    \n    fieldElements.forEach(element => {\n      const fieldName = this.getAttr(element, ATTRS.field) as ExpertField;\n      const format = this.getAttr(element, ATTRS.format);\n      \n      if (!fieldName || !(fieldName in expert)) return;\n\n      const value = expert[fieldName];\n      this.setElementValue(element, value, format);\n    });\n\n    // Handle star ratings\n    const starsElements = this.querySelectorAll(card, '[data-contra-stars]');\n    starsElements.forEach(element => {\n      if (expert.averageReviewScore) {\n        this.renderStarRating(element, expert.averageReviewScore);\n      }\n    });\n  }\n\n  /**\n   * Set element value with proper formatting\n   */\n  private setElementValue(element: Element, value: any, format?: string | null): void {\n    if (value == null || value === '') return;\n\n    // Media type detection and handling\n    if (this.isMediaField(element) && typeof value === 'string' && value.trim()) {\n      this.setMediaValue(element, value);\n      return;\n    }\n\n    if (element instanceof HTMLAnchorElement) {\n      element.href = String(value);\n      if (!element.textContent?.trim()) {\n        element.textContent = String(value);\n      }\n    } else if (element instanceof HTMLInputElement) {\n      element.value = String(value);\n    } else if (element instanceof HTMLImageElement) {\n      // Regular image handling for avatars and other images\n      element.src = String(value);\n      element.alt = element.alt || 'Image';\n    } else {\n      // Text content with formatting\n      let displayValue = String(value);\n      \n      if (format) {\n        switch (format) {\n          case 'currency':\n            displayValue = typeof value === 'number' ? `$${value}` : displayValue;\n            break;\n          case 'rate':\n            displayValue = utils.formatRate(typeof value === 'number' ? value : null);\n            break;\n          case 'rating':\n            // Format rating to one decimal place (5.0, 4.9, etc.)\n            displayValue = typeof value === 'number' ? value.toFixed(1) : displayValue;\n            break;\n          case 'earnings':\n            // Format earnings like $25k+\n            if (typeof value === 'number') {\n              if (value >= 1000000) {\n                displayValue = `$${Math.floor(value / 1000000)}M+`;\n              } else if (value >= 1000) {\n                displayValue = `$${Math.floor(value / 1000)}k+`;\n              } else {\n                displayValue = `$${value}`;\n              }\n            }\n            break;\n          case 'number':\n            displayValue = typeof value === 'number' ? value.toLocaleString() : displayValue;\n            break;\n          case 'truncate':\n            displayValue = displayValue.length > 100 ? displayValue.substring(0, 97) + '...' : displayValue;\n            break;\n          case 'boolean':\n            displayValue = value ? 'Yes' : 'No';\n            break;\n          case 'availability':\n            displayValue = value ? 'Available' : 'Not Available';\n            break;\n        }\n      }\n      \n      element.textContent = displayValue;\n    }\n  }\n\n  /**\n   * Star rating rendering with optional text display\n   */\n  private renderStarRating(element: Element, rating: number): void {\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = rating % 1 >= 0.5;\n    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);\n    \n    let starsHtml = '';\n    \n    // Full stars\n    for (let i = 0; i < fullStars; i++) {\n      starsHtml += '<span class=\"contra-star contra-star-full\">â˜…</span>';\n    }\n    \n    // Half star\n    if (hasHalfStar) {\n      starsHtml += '<span class=\"contra-star contra-star-half\">â˜…</span>';\n    }\n    \n    // Empty stars\n    for (let i = 0; i < emptyStars; i++) {\n      starsHtml += '<span class=\"contra-star contra-star-empty\">â˜†</span>';\n    }\n    \n    element.innerHTML = starsHtml;\n    \n    // Also update any rating text elements in the same card\n    const card = element.closest('[data-contra-template]') || element.closest('.expert-card');\n    if (card) {\n      const ratingTextElements = this.querySelectorAll(card, '[data-contra-rating-text]');\n      ratingTextElements.forEach(textElement => {\n        textElement.textContent = rating.toFixed(1);\n      });\n    }\n  }\n\n  /**\n   * Media type detection and element handling\n   */\n  private isMediaField(element: Element): boolean {\n    const field = this.getAttr(element, ATTRS.field);\n    // Only apply advanced media handling to project cover URLs, not avatars\n    return field === 'coverUrl';\n  }\n\n  /**\n   * Media value setting with automatic type detection\n   */\n  private setMediaValue(element: Element, url: string): void {\n    const mediaType = this.detectMediaType(url);\n    const parent = element.parentElement;\n    \n    if (!parent) {\n      this.log('Media element has no parent for replacement', element);\n      return;\n    }\n\n    // Remove existing media element\n    element.remove();\n\n    // Create appropriate media element\n    let mediaElement: HTMLElement;\n    \n    switch (mediaType) {\n      case 'video':\n        mediaElement = this.createVideoElement(url, element);\n        break;\n      case 'image':\n      default:\n        mediaElement = this.createImageElement(url, element);\n        break;\n    }\n\n    // Preserve classes and attributes from original element\n    this.transferAttributes(element, mediaElement);\n    \n    // Insert new media element\n    parent.appendChild(mediaElement);\n    \n    this.log(`Created ${mediaType} element for URL: ${url}`);\n  }\n\n  /**\n   * Detect media type from URL\n   */\n  private detectMediaType(url: string): 'image' | 'video' {\n    if (!url || typeof url !== 'string') {\n      this.log('Invalid URL provided to detectMediaType:', url);\n      return 'image';\n    }\n    \n    const urlLower = url.toLowerCase();\n    \n    // Video formats\n    const videoExtensions = ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.ogg'];\n    const isVideo = videoExtensions.some(ext => urlLower.includes(ext));\n    \n    // Special handling for Cloudinary video URLs\n    const isCloudinaryVideo = urlLower.includes('cloudinary.com/') && urlLower.includes('/video/');\n    \n    return (isVideo || isCloudinaryVideo) ? 'video' : 'image';\n  }\n\n  /**\n   * Create video element with fallback\n   */\n  private createVideoElement(url: string, originalElement: Element): HTMLVideoElement {\n    const video = document.createElement('video');\n    \n    // Video attributes\n    video.src = url;\n    video.muted = this.config.videoMuted;\n    video.loop = this.config.videoLoop;\n    video.playsInline = true;\n    video.preload = 'metadata';\n    video.controls = this.config.videoControls;\n    \n    // Maintain aspect ratio and object-fit from original\n    video.style.width = '100%';\n    video.style.height = '100%';\n    video.style.objectFit = 'cover';\n    video.style.borderRadius = 'inherit';\n    \n    // Autoplay configuration\n    if (this.config.videoAutoplay) {\n      video.autoplay = true;\n      video.setAttribute('autoplay', '');\n    }\n    \n    // Error handling with fallback to poster or placeholder\n    video.onerror = () => {\n      this.log(`Video failed to load: ${url}`);\n      // Try to extract a thumbnail from Cloudinary video URL\n      const posterUrl = this.extractVideoThumbnail(url);\n      if (posterUrl) {\n        const fallbackImg = this.createImageElement(posterUrl, originalElement);\n        video.parentElement?.replaceChild(fallbackImg, video);\n      } else {\n        // Show placeholder\n        video.style.background = '#f3f4f6';\n        video.style.position = 'relative';\n        video.innerHTML = '<div style=\"position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#9ca3af;font-size:12px;\">Video unavailable</div>';\n      }\n    };\n\n    // Hover-to-play functionality (if enabled and not autoplay)\n    if (this.config.videoHoverPlay && !this.config.videoAutoplay) {\n      video.addEventListener('mouseenter', () => {\n        video.currentTime = 0;\n        video.play().catch(() => {\n          // Ignore play errors (browser policies)\n        });\n      });\n\n      video.addEventListener('mouseleave', () => {\n        video.pause();\n        video.currentTime = 0;\n      });\n    }\n\n    return video;\n  }\n\n  /**\n   * Create image element with error handling\n   */\n  private createImageElement(url: string, originalElement: Element): HTMLImageElement {\n    const img = document.createElement('img');\n    \n    img.src = url;\n    img.alt = originalElement.getAttribute('alt') || 'Media content';\n    img.loading = 'lazy';\n    \n    // Maintain styling\n    img.style.width = '100%';\n    img.style.height = '100%';\n    img.style.objectFit = 'cover';\n    img.style.borderRadius = 'inherit';\n    \n    // Error handling\n    img.onerror = () => {\n      this.log(`Image failed to load: ${url}`);\n      img.style.background = '#f3f4f6';\n      img.style.opacity = '0.5';\n      img.alt = 'Image unavailable';\n      \n      // Add broken image icon\n      img.style.position = 'relative';\n      const placeholder = document.createElement('div');\n      placeholder.style.cssText = `\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        color: #9ca3af;\n        font-size: 12px;\n        text-align: center;\n      `;\n      placeholder.textContent = 'ðŸ–¼ï¸ Image unavailable';\n      img.parentElement?.appendChild(placeholder);\n    };\n\n    return img;\n  }\n\n  /**\n   * Extract video thumbnail from Cloudinary URL\n   */\n  private extractVideoThumbnail(videoUrl: string): string | null {\n    if (videoUrl.includes('cloudinary.com/') && videoUrl.includes('/video/')) {\n      // Convert video URL to image thumbnail\n      return videoUrl\n        .replace('/video/', '/image/')\n        .replace(/\\.(mp4|webm|mov|avi|mkv)$/i, '.jpg')\n        .replace('fl_progressive', 'f_auto,q_auto,c_fill');\n    }\n    return null;\n  }\n\n  /**\n   * Transfer attributes and classes from old element to new\n   */\n  private transferAttributes(from: Element, to: HTMLElement): void {\n    // Transfer classes\n    if (from.className) {\n      to.className = from.className;\n    }\n    \n    // Transfer data attributes (except contra-field)\n    Array.from(from.attributes).forEach(attr => {\n      if (attr.name.startsWith('data-') && attr.name !== `${ATTR_PREFIX}${ATTRS.field}`) {\n        to.setAttribute(attr.name, attr.value);\n      }\n    });\n    \n    // Transfer style\n    if (from.getAttribute('style')) {\n      const existingStyle = to.getAttribute('style') || '';\n      to.setAttribute('style', existingStyle + '; ' + from.getAttribute('style'));\n    }\n  }\n\n  /**\n   * Handle repeating elements (projects, social links)\n   */\n  private populateRepeatingElements(card: Element, expert: ExpertProfile): void {\n    const repeatElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.repeat}]`);\n    \n    repeatElements.forEach(container => {\n      const repeatType = this.getAttr(container, ATTRS.repeat);\n      const maxItems = parseInt(this.getAttr(container, ATTRS.max) || '10');\n      \n      if (repeatType === 'projects' && expert.projects) {\n        this.populateRepeatingContainer(container, expert.projects.slice(0, maxItems));\n      } else if (repeatType === 'socialLinks' && expert.socialLinks) {\n        this.populateRepeatingContainer(container, expert.socialLinks.slice(0, maxItems));\n      } else if (repeatType === 'skillTags' && expert.skillTags) {\n        this.populateRepeatingContainer(container, expert.skillTags.slice(0, maxItems).map((tag: string) => ({ name: tag })));\n      }\n    });\n  }\n\n  /**\n   * Populate a repeating container with items\n   */\n  private populateRepeatingContainer(container: Element, items: any[]): void {\n    const template = container.firstElementChild;\n    if (!template) return;\n\n    // Clear existing items\n    container.innerHTML = '';\n    \n    // Create items from template\n    items.forEach(item => {\n      const itemElement = template.cloneNode(true) as Element;\n      this.populateFields(itemElement, item);\n      container.appendChild(itemElement);\n    });\n    \n    // Hide container if no items\n    if (items.length === 0) {\n      (container as HTMLElement).style.display = 'none';\n    }\n  }\n\n  /**\n   * Handle conditional display based on data\n   */\n  private handleConditionalDisplay(card: Element, expert: ExpertProfile): void {\n    const conditionalElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.showWhen}], [${ATTR_PREFIX}${ATTRS.hideWhen}]`);\n    \n    conditionalElements.forEach(element => {\n      const showWhen = this.getAttr(element, ATTRS.showWhen);\n      const hideWhen = this.getAttr(element, ATTRS.hideWhen);\n      \n      let shouldShow = true;\n      \n      if (showWhen) {\n        shouldShow = this.evaluateCondition(expert, showWhen);\n      }\n      \n      if (hideWhen) {\n        shouldShow = shouldShow && !this.evaluateCondition(expert, hideWhen);\n      }\n      \n      (element as HTMLElement).style.display = shouldShow ? '' : 'none';\n    });\n  }\n\n  /**\n   * Evaluate a condition against expert data\n   */\n  private evaluateCondition(expert: ExpertProfile, condition: string): boolean {\n    if (!condition || typeof condition !== 'string') {\n      this.log('Invalid condition provided:', condition);\n      return false;\n    }\n    \n    // Parse condition: \"field:value\" or \"field:>value\" etc.\n    const parts = condition.split(':');\n    if (parts.length < 2) {\n      this.log('Invalid condition format:', condition);\n      return false;\n    }\n    \n    const field = parts[0];\n    const restOfCondition = parts.slice(1).join(':'); // Handle colons in values\n    const expertValue = (expert as any)[field];\n    \n    this.log(`Evaluating condition: ${field} (${expertValue}, type: ${typeof expertValue}) against ${restOfCondition}`);\n    \n    if (expertValue == null) {\n      this.log(`Field '${field}' is null/undefined, condition fails`);\n      return false;\n    }\n    \n    // Check for comparison operators\n    if (restOfCondition.startsWith('>=')) {\n      const value = restOfCondition.substring(2);\n      const result = Number(expertValue) >= Number(value);\n      this.log(`Comparison: ${expertValue} >= ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('<=')) {\n      const value = restOfCondition.substring(2);\n      const result = Number(expertValue) <= Number(value);\n      this.log(`Comparison: ${expertValue} <= ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('>')) {\n      const value = restOfCondition.substring(1);\n      const result = Number(expertValue) > Number(value);\n      this.log(`Comparison: ${expertValue} > ${value} = ${result}`);\n      return result;\n    } else if (restOfCondition.startsWith('<')) {\n      const value = restOfCondition.substring(1);\n      const result = Number(expertValue) < Number(value);\n      this.log(`Comparison: ${expertValue} < ${value} = ${result}`);\n      return result;\n    } else {\n      // Direct value comparison with type-aware handling\n      let result = false;\n      \n      // Handle boolean fields specially\n      if (typeof expertValue === 'boolean') {\n        // Convert string condition to boolean for comparison\n        if (restOfCondition.toLowerCase() === 'true') {\n          result = expertValue === true;\n        } else if (restOfCondition.toLowerCase() === 'false') {\n          result = expertValue === false;\n        } else {\n          result = false;\n        }\n        this.log(`Boolean comparison: ${expertValue} === ${restOfCondition.toLowerCase() === 'true'} = ${result}`);\n      } else if (typeof expertValue === 'number') {\n        // Handle numeric comparisons\n        const numValue = Number(restOfCondition);\n        result = !isNaN(numValue) && expertValue === numValue;\n        this.log(`Number comparison: ${expertValue} === ${numValue} = ${result}`);\n      } else {\n        // String comparison (case-insensitive)\n        const expertStr = String(expertValue);\n        const valueStr = String(restOfCondition);\n        result = expertStr.toLowerCase() === valueStr.toLowerCase();\n        this.log(`String comparison: '${expertStr}' === '${valueStr}' = ${result}`);\n      }\n      \n      return result;\n    }\n  }\n\n  /**\n   * Update UI states based on current data\n   */\n  private updateUIStates(container: Element, programId: string): void {\n    const state = this.state.getState(programId);\n    \n    // Show/hide empty state\n    const emptyElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.empty}]`);\n    if (emptyElement) {\n      (emptyElement as HTMLElement).style.display = state.experts.length === 0 ? '' : 'none';\n    }\n    \n    // Update pagination info\n    const paginationElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationElements.forEach(element => {\n      const { currentPage, totalCount } = state;\n      const pageSize = state.filters.limit || 20;\n      const totalPages = Math.ceil(totalCount / pageSize);\n      \n      element.textContent = `Page ${currentPage} of ${totalPages} (${totalCount} total)`;\n    });\n    \n    // Update filter summaries\n    const filterSummaries = this.querySelectorAll(container, '[data-contra-filter-summary]');\n    filterSummaries.forEach(element => {\n      const activeFilters = Object.entries(state.filters)\n        .filter(([_key, value]) => value != null && value !== '')\n        .map(([key, value]) => `${key}: ${value}`)\n        .join(', ');\n      \n      element.textContent = activeFilters || 'No filters applied';\n    });\n  }\n\n  /**\n   * Handle action buttons (pagination, sorting, etc.)\n   */\n  private handleAction(programId: string, action: string, _target?: string | null, button?: Element): void {\n    const state = this.state.getState(programId);\n    const container = document.querySelector(`[data-program-id=\"${programId}\"]`);\n    \n    if (!container) {\n      this.log(`Container not found for program: ${programId}`);\n      return;\n    }\n\n    // Show button feedback\n    if (button && button instanceof HTMLButtonElement) {\n      const originalText = button.textContent;\n      button.disabled = true;\n    }\n    \n    switch (action) {\n      case 'next-page':\n        const limit = state.filters.limit || 20;\n        const nextOffset = (state.filters.offset || 0) + limit;\n        \n        if (nextOffset < state.totalCount) {\n          this.updateFilter(programId, 'offset', nextOffset);\n          // Use page navigation mode for caching\n          setTimeout(() => {\n            this.loadExperts(container as Element, programId, true);\n          }, 0);\n        }\n        break;\n        \n      case 'prev-page':\n        const prevOffset = Math.max(0, (state.filters.offset || 0) - (state.filters.limit || 20));\n        this.updateFilter(programId, 'offset', prevOffset);\n        // Use page navigation mode for caching\n        setTimeout(() => {\n          this.loadExperts(container as Element, programId, true);\n        }, 0);\n        break;\n        \n      case 'load-more':\n        // Handle load more for all pagination modes\n        this.loadMoreExperts(container as Element, programId).finally(() => {\n          if (button && button instanceof HTMLButtonElement) {\n            button.disabled = false;\n          }\n        });\n        return; // Exit early to avoid re-enabling button\n        \n      case 'first-page':\n        this.updateFilter(programId, 'offset', 0);\n        setTimeout(() => {\n          this.loadExperts(container as Element, programId, true);\n        }, 0);\n        break;\n        \n      case 'last-page':\n        const lastPageOffset = Math.max(0, Math.floor((state.totalCount - 1) / (state.filters.limit || 20)) * (state.filters.limit || 20));\n        this.updateFilter(programId, 'offset', lastPageOffset);\n        setTimeout(() => {\n          this.loadExperts(container as Element, programId, true);\n        }, 0);\n        break;\n        \n      case 'clear-filters':\n        // Reset pagination when clearing filters\n        this.state.updateState(programId, { \n          filters: { limit: state.filters.limit }, // Keep limit\n          currentPage: 1,\n          cachedPages: new Map() // Clear cache\n        });\n        if (this.config.autoReload) {\n          this.debouncedReload.get(programId)?.();\n        }\n        break;\n        \n      case 'reload':\n        // Clear cache and reload\n        this.state.updateState(programId, { cachedPages: new Map() });\n        this.client.clearCache(`experts:${programId}`);\n        if (this.config.autoReload) {\n          this.debouncedReload.get(programId)?.();\n        }\n        break;\n    }\n    \n    // Re-enable button after action completes\n    if (button && button instanceof HTMLButtonElement && action !== 'load-more') {\n      setTimeout(() => {\n        button.disabled = false;\n      }, 100);\n    }\n  }\n\n  /**\n   * Load more experts - unified method for all pagination modes\n   */\n  private async loadMoreExperts(container: Element, programId: string): Promise<void> {\n    const state = this.state.getState(programId);\n    const limit = state.filters.limit || 20;\n    const currentOffset = state.experts.length; // Use actual loaded count as offset\n    \n    this.log(`Loading more experts: current loaded=${state.experts.length}, fetching ${limit} more`);\n\n    try {\n      this.state.updateState(programId, { isInfiniteLoading: true });\n      this.updateLoadMoreButtonState(container, programId, true);\n\n      // Fetch next batch with current offset\n      const response = await this.client.listExperts(programId, {\n        ...state.filters,\n        offset: currentOffset,\n        limit: limit\n      });\n\n      this.log(`Loaded ${response.data.length} more experts (total now: ${state.experts.length + response.data.length})`);\n\n      // Append new experts to existing ones\n      const allExperts = [...state.experts, ...response.data];\n      const newPage = Math.floor(currentOffset / limit) + 2; // +2 because we're loading the next page\n      \n      this.state.updateState(programId, {\n        experts: allExperts,\n        currentPage: newPage,\n        totalCount: response.totalCount,\n        hasNextPage: allExperts.length < response.totalCount,\n        isInfiniteLoading: false\n      });\n\n      // Cache the new page\n      this.state.cachePage(programId, newPage, response.data);\n\n      // Render only the new experts (append mode)\n      this.renderNewExperts(container, response.data);\n      \n      // Update pagination controls\n      this.updatePaginationControls(container, programId);\n\n      // Dispatch event\n      this.dispatchEvent(container, 'expertsLoaded', {\n        experts: response.data,\n        totalExperts: allExperts,\n        totalCount: response.totalCount,\n        page: newPage,\n        isLoadMore: true\n      });\n\n    } catch (error) {\n      this.log(`Failed to load more experts`, error);\n      this.state.updateState(programId, { isInfiniteLoading: false });\n      \n      // Show error in load more button\n      this.updateLoadMoreButtonState(container, programId, false, 'Error loading more');\n      \n      setTimeout(() => {\n        this.updateLoadMoreButtonState(container, programId, false);\n      }, 3000);\n    } finally {\n      this.updateLoadMoreButtonState(container, programId, false);\n    }\n  }\n\n  /**\n   * Update load more button state\n   */\n  private updateLoadMoreButtonState(container: Element, programId: string, loading: boolean, errorText?: string): void {\n    const loadMoreButtons = this.querySelectorAll(container, '[data-contra-action=\"load-more\"]');\n    const state = this.state.getState(programId);\n    \n    loadMoreButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      \n      if (errorText) {\n        btnElement.textContent = errorText;\n        btnElement.disabled = true;\n        btnElement.classList.add('error');\n        return;\n      }\n      \n      btnElement.classList.remove('error');\n      \n      if (loading) {\n        btnElement.textContent = 'Loading...';\n        btnElement.disabled = true;\n        btnElement.classList.add('loading');\n      } else {\n        btnElement.classList.remove('loading');\n        const hasMore = state.experts.length < state.totalCount;\n        \n        if (hasMore) {\n          btnElement.textContent = this.config.loadMoreText;\n          btnElement.disabled = false;\n        } else {\n          btnElement.textContent = 'All experts loaded';\n          btnElement.disabled = true;\n          btnElement.classList.add('disabled');\n        }\n      }\n    });\n  }\n\n  /**\n   * Load next page for infinite scroll\n   */\n  private async loadNextPageInfinite(container: Element, programId: string): Promise<void> {\n    // Use the unified loadMoreExperts method\n    return this.loadMoreExperts(container, programId);\n  }\n\n  /**\n   * Update pagination control states\n   */\n  private updatePaginationControls(container: Element, programId: string): void {\n    const state = this.state.getState(programId);\n    const limit = state.filters.limit || 20;\n    const totalPages = Math.ceil(state.totalCount / limit);\n    \n    // Update button states\n    const prevButtons = this.querySelectorAll(container, '[data-contra-action=\"prev-page\"]');\n    const nextButtons = this.querySelectorAll(container, '[data-contra-action=\"next-page\"]');\n\n    // Previous page buttons\n    prevButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = state.currentPage <= 1;\n      btnElement.classList.toggle('disabled', state.currentPage <= 1);\n    });\n\n    // Next page buttons\n    nextButtons.forEach(button => {\n      const btnElement = button as HTMLButtonElement;\n      btnElement.disabled = state.currentPage >= totalPages;\n      btnElement.classList.toggle('disabled', state.currentPage >= totalPages);\n    });\n\n    // Update load more buttons\n    this.updateLoadMoreButtonState(container, programId, state.isInfiniteLoading);\n\n    // Update pagination info elements\n    const paginationInfoElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationInfoElements.forEach(element => {\n      const loadedCount = state.experts.length;\n      const totalCount = state.totalCount;\n      \n      // Different info based on pagination mode\n      if (state.paginationMode === 'infinite' || state.paginationMode === 'hybrid') {\n        element.textContent = `Showing ${loadedCount} of ${totalCount} experts`;\n      } else {\n        element.textContent = `Page ${state.currentPage} of ${totalPages} (${totalCount} total)`;\n      }\n    });\n\n    this.log(`Pagination controls updated: loaded ${state.experts.length}/${state.totalCount}, hasNext: ${state.hasNextPage}`);\n  }\n\n  /**\n   * Update infinite loading state\n   */\n  private updateInfiniteLoadingState(container: Element, loading: boolean): void {\n    const loadingIndicators = this.querySelectorAll(container, '[data-contra-infinite-loading]');\n    \n    loadingIndicators.forEach(indicator => {\n      (indicator as HTMLElement).style.display = loading ? '' : 'none';\n    });\n  }\n\n  /**\n   * Render new experts for infinite scroll (append mode)\n   */\n  private renderNewExperts(container: Element, newExperts: ExpertProfile[]): void {\n    const template = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.template}]`);\n    if (!template) {\n      this.log('No template found for rendering new experts', container);\n      return;\n    }\n\n    // Create a document fragment for efficient DOM manipulation\n    const fragment = document.createDocumentFragment();\n\n    newExperts.forEach(expert => {\n      const expertCard = this.populateExpertCard(template, expert);\n      fragment.appendChild(expertCard);\n    });\n\n    // Append all new cards at once\n    container.appendChild(fragment);\n\n    this.log(`Rendered ${newExperts.length} new expert cards for load more`);\n  }\n\n  // ... (utility methods continue below)\n\n  /**\n   * Utility Methods\n   */\n  private getAttr(element: Element, name: string): string | null {\n    return element.getAttribute(`${ATTR_PREFIX}${name}`);\n  }\n\n  private querySelector(element: Element, selector: string): Element | null {\n    return element.querySelector(selector);\n  }\n\n  private querySelectorAll(element: Element, selector: string): Element[] {\n    return Array.from(element.querySelectorAll(selector));\n  }\n\n  private findExpertContainers(): Element[] {\n    return Array.from(document.querySelectorAll(`[${ATTR_PREFIX}${ATTRS.program}]`));\n  }\n\n  private parseFiltersFromElement(element: Element): ExpertFilters {\n    const filters: ExpertFilters = {};\n    \n    // Parse filter attributes\n    const filterMap = {\n      'available': 'available',\n      'languages': 'languages', \n      'location': 'location',\n      'min-rate': 'minRate',\n      'max-rate': 'maxRate',\n      'sort': 'sortBy',\n      'limit': 'limit',\n      'offset': 'offset'\n    };\n\n    Object.entries(filterMap).forEach(([attr, filterKey]) => {\n      const value = this.getAttr(element, attr);\n      if (value != null) {\n        if (filterKey === 'available') {\n          (filters as any)[filterKey] = value === 'true';\n        } else if (filterKey === 'languages') {\n          (filters as any)[filterKey] = value.split(',').map(v => v.trim());\n        } else if (['minRate', 'maxRate', 'limit', 'offset'].includes(filterKey)) {\n          (filters as any)[filterKey] = parseInt(value);\n        } else {\n          (filters as any)[filterKey] = value;\n        }\n      }\n    });\n\n    return filters;\n  }\n\n  private getControlValue(control: HTMLInputElement | HTMLSelectElement): any {\n    if (control instanceof HTMLInputElement) {\n      switch (control.type) {\n        case 'checkbox':\n          return control.checked;\n        case 'number':\n        case 'range':\n          return control.valueAsNumber;\n        default:\n          return control.value;\n      }\n    } else if (control instanceof HTMLSelectElement) {\n      if (control.multiple) {\n        return Array.from(control.selectedOptions).map(option => option.value);\n      }\n      return control.value;\n    }\n    return null;\n  }\n\n  private updateFilter(programId: string, filterKey: string, value: any, type: string = 'replace'): void {\n    const state = this.state.getState(programId);\n    const newFilters = { ...state.filters };\n\n    // Handle special cases for filter value conversion\n    let processedValue = value;\n    \n    if (filterKey === 'available') {\n      // Convert string values to boolean for availability filter\n      if (typeof value === 'string') {\n        if (value === 'true') {\n          processedValue = true;\n        } else if (value === 'false') {\n          processedValue = false;\n        } else if (value === '' || value === null) {\n          processedValue = undefined; // No filter\n        }\n      }\n    } else if (filterKey === 'minRate' || filterKey === 'maxRate') {\n      // Convert empty strings to undefined for rate filters\n      if (value === '' || value === null) {\n        processedValue = undefined;\n      } else {\n        processedValue = Number(value);\n      }\n    }\n\n    if (type === 'append' && Array.isArray(newFilters[filterKey as keyof ExpertFilters])) {\n      const currentArray = newFilters[filterKey as keyof ExpertFilters] as any[];\n      newFilters[filterKey as keyof ExpertFilters] = [...currentArray, processedValue] as any;\n    } else {\n      (newFilters as any)[filterKey] = processedValue;\n    }\n\n    this.state.updateState(programId, { filters: newFilters });\n    \n    this.log(`Filter updated: ${filterKey} = ${processedValue} (original: ${value})`);\n    \n    // Dispatch filter change event\n    const event: FilterChangeEvent = {\n      filters: newFilters,\n      element: document.querySelector(`[data-program-id=\"${programId}\"]`) as HTMLElement\n    };\n    \n    this.dispatchEvent(document as any, 'filterChange', event);\n  }\n\n  private showLoading(container: Element, show: boolean): void {\n    const loadingElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.loading}]`);\n    if (loadingElement) {\n      (loadingElement as HTMLElement).style.display = show ? '' : 'none';\n    }\n    \n    (container as HTMLElement).classList.toggle(this.config.loadingClass, show);\n  }\n\n  private showError(container: Element, error: Error): void {\n    const errorElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.error}]`);\n    if (errorElement) {\n      errorElement.textContent = error.message;\n      (errorElement as HTMLElement).style.display = '';\n    }\n    \n    (container as HTMLElement).classList.add(this.config.errorClass);\n    this.log('Error displayed', error);\n  }\n\n  private dispatchEvent(target: Element | Document, eventName: string, detail: any): void {\n    const event = new CustomEvent(`contra:${eventName}`, { detail });\n    target.dispatchEvent(event);\n  }\n\n  private log(message: string, ...args: any[]): void {\n    if (this.config.debug) {\n      console.log(`[ContraWebflow] ${message}`, ...args);\n    }\n  }\n}\n\n/**\n * Auto-initialize runtime when DOM is ready\n */\nfunction autoInit(): void {\n  const configElement = document.getElementById('contra-config');\n  if (!configElement) {\n    console.warn('[ContraWebflow] No config element found. Runtime not initialized.');\n    return;\n  }\n\n  try {\n    const config = JSON.parse(configElement.textContent || '{}');\n    const runtime = new ContraWebflowRuntime(config);\n    \n    // Expose runtime globally for debugging\n    (window as any).contraRuntime = runtime;\n    \n    runtime.init().catch(error => {\n      console.error('[ContraWebflow] Runtime initialization failed:', error);\n    });\n    \n  } catch (error) {\n    console.error('[ContraWebflow] Failed to parse config:', error);\n  }\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\n// Export runtime class for manual initialization\nexport { ContraWebflowRuntime as default }; ","import type {\n  ClientConfig,\n  ExpertProfile,\n  ExpertFilters,\n  ProgramSummary,\n  ListResponse,\n  ApiResponse,\n  ErrorResponse,\n  Filter,\n  FilterListResponse\n} from '@contra/types';\n\n/**\n * Professional Contra API Client\n * Features: Caching, retry logic, error handling, request deduplication\n */\nexport class ContraClient {\n  private config: Required<ClientConfig>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n  private pendingRequests = new Map<string, Promise<any>>();\n  \n  // Cache TTL settings (in milliseconds)\n  private static readonly CACHE_TTL = {\n    experts: 5 * 60 * 1000,      // 5 minutes for expert lists\n    expert: 10 * 60 * 1000,     // 10 minutes for individual experts\n    program: 30 * 60 * 1000,    // 30 minutes for program info\n    filters: 60 * 60 * 1000,    // 1 hour for available filters\n  };\n\n  constructor(config: ClientConfig) {\n    this.config = {\n      baseUrl: 'https://contra.com',\n      timeout: 10000,\n      debug: false,\n      ...config,\n    };\n\n    if (this.config.debug) {\n      console.log('[ContraClient] Initialized with config:', this.config);\n    }\n  }\n\n  /**\n   * Core fetch method with retry logic and error handling\n   */\n  private async fetch<T>(\n    endpoint: string,\n    options: RequestInit = {},\n    retries = 3\n  ): Promise<T> {\n    const url = `${this.config.baseUrl}${endpoint}`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n    const requestOptions: RequestInit = {\n      ...options,\n      signal: controller.signal,\n      headers: {\n        'Accept': 'application/json',\n        'X-API-key': this.config.apiKey,\n        ...options.headers,\n      },\n    };\n\n    try {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Fetching: ${url}`, requestOptions);\n      }\n\n      const response = await fetch(url, requestOptions);\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        // Try to parse error response\n        let errorData: ErrorResponse;\n        try {\n          errorData = await response.json();\n        } catch {\n          errorData = {\n            code: `HTTP_${response.status}`,\n            message: response.statusText || 'Unknown error'\n          };\n        }\n\n        // Retry on 5xx errors or rate limits\n        if ((response.status >= 500 || response.status === 429) && retries > 0) {\n          const delay = Math.pow(2, 3 - retries) * 1000; // Exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return this.fetch<T>(endpoint, options, retries - 1);\n        }\n\n        throw new ContraAPIError(errorData.message, errorData.code, response.status);\n      }\n\n      const data = await response.json();\n      \n      if (this.config.debug) {\n        console.log(`[ContraClient] Response:`, data);\n      }\n\n      return data;\n\n    } catch (error) {\n      clearTimeout(timeoutId);\n      \n      if (error instanceof ContraAPIError) {\n        throw error;\n      }\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new ContraAPIError(`Request timeout after ${this.config.timeout}ms`, 'TIMEOUT');\n      }\n\n      // Network or other errors - retry if we have retries left\n      if (retries > 0) {\n        const delay = Math.pow(2, 3 - retries) * 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.fetch<T>(endpoint, options, retries - 1);\n      }\n\n      throw new ContraAPIError(\n        error instanceof Error ? error.message : 'Unknown error',\n        'NETWORK_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Get from cache or fetch with request deduplication\n   */\n  private async fetchWithCache<T>(\n    cacheKey: string,\n    endpoint: string,\n    ttl: number,\n    options?: RequestInit\n  ): Promise<T> {\n    // Check cache first\n    const cached = this.cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < cached.ttl) {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Cache hit: ${cacheKey}`);\n      }\n      return cached.data;\n    }\n\n    // Check for pending request (deduplication)\n    const pendingKey = `${endpoint}${JSON.stringify(options)}`;\n    if (this.pendingRequests.has(pendingKey)) {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Request deduplication: ${pendingKey}`);\n      }\n      return this.pendingRequests.get(pendingKey)!;\n    }\n\n    // Make the request\n    const requestPromise = this.fetch<T>(endpoint, options);\n    this.pendingRequests.set(pendingKey, requestPromise);\n\n    try {\n      const data = await requestPromise;\n      \n      // Cache the result\n      this.cache.set(cacheKey, {\n        data,\n        timestamp: Date.now(),\n        ttl\n      });\n\n      return data;\n    } finally {\n      this.pendingRequests.delete(pendingKey);\n    }\n  }\n\n  /**\n   * Build query string from filters\n   */\n  private buildQueryString(filters: ExpertFilters): string {\n    const params = new URLSearchParams();\n    \n    Object.entries(filters).forEach(([key, value]) => {\n      if (value != null && value !== '') {\n        if (Array.isArray(value)) {\n          params.set(key, value.join(','));\n        } else {\n          params.set(key, String(value));\n        }\n      }\n    });\n\n    const queryString = params.toString();\n    return queryString ? `?${queryString}` : '';\n  }\n\n  /**\n   * Get program information\n   */\n  async getProgram(programNid: string): Promise<ProgramSummary> {\n    const cacheKey = `program:${programNid}`;\n    const endpoint = `/public-api/programs/${programNid}`;\n    \n    const response = await this.fetchWithCache<ApiResponse<ProgramSummary>>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.program\n    );\n    \n    return response.data;\n  }\n\n  /**\n   * List experts with advanced filtering and caching\n   */\n  async listExperts(\n    programNid: string,\n    filters: ExpertFilters = {}\n  ): Promise<ListResponse<ExpertProfile>> {\n    const queryString = this.buildQueryString(filters);\n    const cacheKey = `experts:${programNid}:${JSON.stringify(filters)}`;\n    const endpoint = `/public-api/programs/${programNid}/experts${queryString}`;\n    \n    return this.fetchWithCache<ListResponse<ExpertProfile>>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.experts\n    );\n  }\n\n  /**\n   * Search experts (using the main experts endpoint with filters)\n   */\n  async searchExperts(\n    programNid: string,\n    query: string,\n    filters: ExpertFilters = {}\n  ): Promise<ListResponse<ExpertProfile>> {\n    // Search is handled by client-side filtering since API doesn't support text search\n    const experts = await this.listExperts(programNid, filters);\n    \n    // Client-side filtering for search (since API doesn't support text search)\n    if (query.trim()) {\n      const searchTerm = query.toLowerCase();\n      experts.data = experts.data.filter(expert => \n        (expert.name && expert.name.toLowerCase().includes(searchTerm)) ||\n        (expert.oneLiner && expert.oneLiner.toLowerCase().includes(searchTerm)) ||\n        (expert.skillTags && expert.skillTags.some(tag => tag && tag.toLowerCase().includes(searchTerm)))\n      );\n    }\n    \n    return experts;\n  }\n\n  /**\n   * Get available filter options for a program\n   */\n  async getFilterOptions(programNid: string): Promise<FilterListResponse> {\n    const cacheKey = `filters:${programNid}`;\n    const endpoint = `/public-api/programs/${programNid}/filters`;\n    \n    return this.fetchWithCache<FilterListResponse>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.filters\n    );\n  }\n\n  /**\n   * Clear cache (useful for forced refreshes)\n   */\n  clearCache(pattern?: string): void {\n    if (pattern) {\n      // Clear specific cache entries\n      for (const key of this.cache.keys()) {\n        if (key.includes(pattern)) {\n          this.cache.delete(key);\n        }\n      }\n    } else {\n      // Clear all cache\n      this.cache.clear();\n    }\n\n    if (this.config.debug) {\n      console.log(`[ContraClient] Cache cleared${pattern ? ` (pattern: ${pattern})` : ''}`);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): {\n    size: number;\n    entries: Array<{ key: string; age: number; ttl: number }>;\n  } {\n    const now = Date.now();\n    const entries = Array.from(this.cache.entries()).map(([key, value]) => ({\n      key,\n      age: now - value.timestamp,\n      ttl: value.ttl\n    }));\n\n    return {\n      size: this.cache.size,\n      entries\n    };\n  }\n}\n\n/**\n * Custom error class for API errors\n */\nexport class ContraAPIError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public status?: number\n  ) {\n    super(message);\n    this.name = 'ContraAPIError';\n  }\n}\n\n/**\n * Utility functions\n */\nexport const utils = {\n  /**\n   * Format hourly rate with proper handling of null values\n   */\n  formatRate(rate: number | null): string {\n    return rate ? `$${rate}/hr` : 'Rate on request';\n  },\n\n  /**\n   * Generate star rating HTML\n   */\n  renderStars(rating: number): string {\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = (rating % 1) >= 0.5;\n    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);\n    \n    let html = '';\n    \n    // Full stars\n    for (let i = 0; i < fullStars; i++) {\n      html += `<svg class=\"star star-full\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"#FFD700\">\n        <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    // Half star\n    if (hasHalfStar) {\n      html += `<svg class=\"star star-half\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\n        <defs>\n          <linearGradient id=\"half-${rating}\">\n            <stop offset=\"50%\" stop-color=\"#FFD700\"/>\n            <stop offset=\"50%\" stop-color=\"#E5E5E5\"/>\n          </linearGradient>\n        </defs>\n        <path fill=\"url(#half-${rating})\" d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    // Empty stars\n    for (let i = 0; i < emptyStars; i++) {\n      html += `<svg class=\"star star-empty\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"#E5E5E5\">\n        <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    return html;\n  },\n\n  /**\n   * Debounce function for search inputs\n   */\n  debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait: number\n  ): (...args: Parameters<T>) => void {\n    let timeout: NodeJS.Timeout;\n    return (...args: Parameters<T>) => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func(...args), wait);\n    };\n  },\n\n  /**\n   * Throttle function for scroll events\n   */\n  throttle<T extends (...args: any[]) => any>(\n    func: T,\n    limit: number\n  ): (...args: Parameters<T>) => void {\n    let inThrottle: boolean;\n    return (...args: Parameters<T>) => {\n      if (!inThrottle) {\n        func(...args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n}; "],"mappings":"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","names":["runtime_exports","__export","ContraWebflowRuntime","_ContraClient","config","endpoint","options","retries","url","controller","timeoutId","requestOptions","response","errorData","delay","resolve","ContraAPIError","data","error","cacheKey","ttl","cached","pendingKey","requestPromise","filters","params","key","value","queryString","programNid","query","experts","searchTerm","expert","tag","pattern","now","entries","ContraClient","message","code","status","utils","rate","rating","fullStars","hasHalfStar","emptyStars","html","i","func","wait","timeout","args","limit","inThrottle","ATTR_PREFIX","ATTRS","RuntimeState","programId","updates","state","pageNumber","experts","oldestPage","loading","ContraWebflowRuntime","config","f","containers","container","error","element","initialFilters","paginationMode","debouncedReload","d","mode","isScrolling","handleScroll","scrollPosition","documentHeight","threshold","button","filterControls","control","filterKey","filterType","eventType","action","target","e","isPageNavigation","currentPage","cachedExperts","response","limit","offset","page","totalPages","hasNextPage","hasPreviousPage","template","card","expert","expertCard","fieldName","format","value","displayValue","rating","fullStars","hasHalfStar","emptyStars","starsHtml","i","textElement","url","mediaType","parent","mediaElement","urlLower","isVideo","ext","isCloudinaryVideo","originalElement","video","posterUrl","fallbackImg","img","placeholder","videoUrl","from","to","attr","existingStyle","repeatType","maxItems","tag","items","item","itemElement","showWhen","hideWhen","shouldShow","condition","parts","field","restOfCondition","expertValue","result","numValue","expertStr","valueStr","emptyElement","totalCount","pageSize","activeFilters","_key","key","_target","originalText","nextOffset","prevOffset","lastPageOffset","currentOffset","allExperts","newPage","errorText","loadMoreButtons","btnElement","prevButtons","nextButtons","loadedCount","indicator","newExperts","fragment","name","selector","filters","v","option","type","newFilters","processedValue","currentArray","event","show","loadingElement","errorElement","eventName","detail","message","args","autoInit","configElement","runtime"]}