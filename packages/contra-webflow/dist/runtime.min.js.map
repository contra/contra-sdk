{"version":3,"sources":["../src/runtime.ts","../../contra-client/src/client.ts"],"sourcesContent":["import { ContraClient, utils } from '@contra/client';\nimport type {\n  ExpertProfile,\n  ExpertFilters,\n  FilterChangeEvent,\n  ExpertLoadEvent,\n  ErrorEvent,\n  ExpertField\n} from '@contra/types';\n\n/**\n * Professional Webflow Runtime for Contra Experts\n * Features: Performance optimization, advanced filtering, error handling, loading states\n */\n\n// Configuration interface\ninterface RuntimeConfig {\n  apiKey: string;\n  debug?: boolean;\n  loadingClass?: string;\n  errorClass?: string;\n  emptyClass?: string;\n  autoReload?: boolean;\n  debounceDelay?: number;\n  maxRetries?: number;\n}\n\n// Attribute constants\nconst ATTR_PREFIX = 'data-contra-';\nconst ATTRS = {\n  // Core attributes\n  program: 'program',\n  template: 'template',\n  loading: 'loading',\n  error: 'error',\n  empty: 'empty',\n  \n  // Field binding\n  field: 'field',\n  format: 'format',\n  \n  // Repeating elements\n  repeat: 'repeat',\n  max: 'max',\n  \n  // Filter controls\n  filter: 'filter',\n  filterType: 'filter-type',\n  \n  // Sorting and pagination\n  sort: 'sort',\n  page: 'page',\n  limit: 'limit',\n  \n  // UI states\n  showWhen: 'show-when',\n  hideWhen: 'hide-when',\n  \n  // Actions\n  action: 'action',\n  target: 'target'\n} as const;\n\n// State management\nclass RuntimeState {\n  private states = new Map<string, {\n    filters: ExpertFilters;\n    experts: ExpertProfile[];\n    loading: boolean;\n    error: Error | null;\n    currentPage: number;\n    totalCount: number;\n  }>();\n\n  getState(programId: string) {\n    if (!this.states.has(programId)) {\n      this.states.set(programId, {\n        filters: {},\n        experts: [],\n        loading: false,\n        error: null,\n        currentPage: 1,\n        totalCount: 0\n      });\n    }\n    return this.states.get(programId)!;\n  }\n\n  updateState(programId: string, updates: Partial<ReturnType<RuntimeState['getState']>>) {\n    const state = this.getState(programId);\n    Object.assign(state, updates);\n    this.states.set(programId, state);\n  }\n}\n\n/**\n * Main Runtime Class\n */\nexport class ContraWebflowRuntime {\n  private client: ContraClient;\n  private config: Required<RuntimeConfig>;\n  private state = new RuntimeState();\n  private debouncedReload: Map<string, () => void> = new Map();\n\n  constructor(config: RuntimeConfig) {\n    this.config = {\n      debug: false,\n      loadingClass: 'loading',\n      errorClass: 'error',\n      emptyClass: 'empty',\n      autoReload: true,\n      debounceDelay: 300,\n      maxRetries: 3,\n      ...config\n    };\n\n    this.client = new ContraClient({\n      apiKey: this.config.apiKey,\n      debug: this.config.debug\n    });\n\n    this.log('Runtime initialized', this.config);\n  }\n\n  /**\n   * Initialize the runtime and find all expert containers\n   */\n  async init(): Promise<void> {\n    this.log('Initializing runtime...');\n\n    try {\n      // Find all expert containers\n      const containers = this.findExpertContainers();\n      this.log(`Found ${containers.length} expert containers`);\n\n      // Initialize each container\n      for (const container of containers) {\n        await this.initContainer(container);\n      }\n\n      this.log('Runtime initialization complete');\n    } catch (error) {\n      this.log('Runtime initialization failed', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize a single expert container\n   */\n  private async initContainer(container: Element): Promise<void> {\n    const programId = this.getAttr(container, ATTRS.program);\n    if (!programId) {\n      this.log('Container missing program ID', container);\n      return;\n    }\n\n    this.log(`Initializing container for program: ${programId}`);\n\n    try {\n      // Setup container state\n      this.setupContainer(container, programId);\n      \n      // Wire up filter controls\n      this.wireFilterControls(container, programId);\n      \n      // Wire up action buttons\n      this.wireActionButtons(container, programId);\n      \n      // Load initial data\n      await this.loadExperts(container, programId);\n\n    } catch (error) {\n      this.log(`Failed to initialize container for program ${programId}`, error);\n      this.showError(container, error as Error);\n    }\n  }\n\n  /**\n   * Setup container with initial state and classes\n   */\n  private setupContainer(container: Element, programId: string): void {\n    const element = container as HTMLElement;\n    \n    // Add runtime classes\n    element.classList.add('contra-runtime');\n    element.setAttribute('data-program-id', programId);\n    \n    // Parse initial filters from attributes\n    const initialFilters = this.parseFiltersFromElement(container);\n    this.state.updateState(programId, { filters: initialFilters });\n    \n    // Create debounced reload function\n    const debouncedReload = utils.debounce(() => {\n      this.loadExperts(container, programId);\n    }, this.config.debounceDelay);\n    \n    this.debouncedReload.set(programId, debouncedReload);\n    \n    this.log(`Container setup complete for program: ${programId}`, initialFilters);\n  }\n\n  /**\n   * Wire up filter controls to auto-update\n   */\n  private wireFilterControls(container: Element, programId: string): void {\n    const filterControls = this.querySelectorAll(container, `[${ATTR_PREFIX}${ATTRS.filter}]`);\n    \n    this.log(`Found ${filterControls.length} filter controls for program: ${programId}`);\n\n    filterControls.forEach(control => {\n      const filterKey = this.getAttr(control, ATTRS.filter);\n      const filterType = this.getAttr(control, ATTRS.filterType) || 'replace';\n      \n      if (!filterKey) return;\n\n      // Add event listeners based on control type\n      if (control instanceof HTMLInputElement) {\n        const eventType = control.type === 'range' || control.type === 'number' ? 'input' : 'change';\n        \n        control.addEventListener(eventType, () => {\n          this.updateFilter(programId, filterKey, this.getControlValue(control), filterType);\n          if (this.config.autoReload) {\n            this.debouncedReload.get(programId)?.();\n          }\n        });\n        \n      } else if (control instanceof HTMLSelectElement) {\n        control.addEventListener('change', () => {\n          this.updateFilter(programId, filterKey, this.getControlValue(control), filterType);\n          if (this.config.autoReload) {\n            this.debouncedReload.get(programId)?.();\n          }\n        });\n      }\n      \n      this.log(`Wired filter control: ${filterKey} (${filterType})`, control);\n    });\n  }\n\n  /**\n   * Wire up action buttons (pagination, sorting, etc.)\n   */\n  private wireActionButtons(container: Element, programId: string): void {\n    const actionButtons = this.querySelectorAll(container, `[${ATTR_PREFIX}${ATTRS.action}]`);\n    \n    actionButtons.forEach(button => {\n      const action = this.getAttr(button, ATTRS.action);\n      const target = this.getAttr(button, ATTRS.target);\n      \n      if (!action) return;\n\n      button.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.handleAction(programId, action, target, button);\n      });\n    });\n  }\n\n  /**\n   * Load experts for a program\n   */\n  private async loadExperts(container: Element, programId: string): Promise<void> {\n    const state = this.state.getState(programId);\n    \n    this.log(`Loading experts for program: ${programId}`, state.filters);\n\n    try {\n      // Show loading state\n      this.showLoading(container, true);\n      this.state.updateState(programId, { loading: true, error: null });\n\n      // Fetch experts\n      const response = await this.client.listExperts(programId, state.filters);\n      \n      this.log(`Loaded ${response.data.length} experts`, response);\n\n      // Update state\n      this.state.updateState(programId, {\n        experts: response.data,\n        totalCount: response.totalCount,\n        loading: false\n      });\n\n      // Render experts\n      this.renderExperts(container, response.data);\n      \n      // Update UI states\n      this.updateUIStates(container, programId);\n      \n      // Dispatch event\n      this.dispatchEvent(container, 'expertsLoaded', {\n        experts: response.data,\n        totalCount: response.totalCount,\n        filters: state.filters\n      } as ExpertLoadEvent);\n\n    } catch (error) {\n      this.log(`Failed to load experts for program: ${programId}`, error);\n      \n      this.state.updateState(programId, { \n        loading: false, \n        error: error as Error \n      });\n      \n      this.showError(container, error as Error);\n      \n      // Dispatch error event\n      this.dispatchEvent(container, 'expertsError', {\n        error: error as Error,\n        context: `Loading experts for program ${programId}`\n      } as ErrorEvent);\n    } finally {\n      this.showLoading(container, false);\n    }\n  }\n\n  /**\n   * Render experts into the container\n   */\n  private renderExperts(container: Element, experts: ExpertProfile[]): void {\n    const template = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.template}]`);\n    if (!template) {\n      this.log('No template found in container', container);\n      return;\n    }\n\n    // Clear existing expert cards (keep template)\n    const existingCards = this.querySelectorAll(container, ':scope > *:not([data-contra-template]):not([data-contra-loading]):not([data-contra-error]):not([data-contra-empty])');\n    existingCards.forEach(card => card.remove());\n\n    // Render expert cards\n    experts.forEach(expert => {\n      const expertCard = this.populateExpertCard(template, expert);\n      container.appendChild(expertCard);\n    });\n\n    this.log(`Rendered ${experts.length} expert cards`);\n  }\n\n  /**\n   * Populate expert card from template\n   */\n  private populateExpertCard(template: Element, expert: ExpertProfile): Element {\n    const card = template.cloneNode(true) as Element;\n    \n    // Remove template attribute and show the card\n    card.removeAttribute(`${ATTR_PREFIX}${ATTRS.template}`);\n    (card as HTMLElement).style.display = '';\n\n    // Populate field bindings\n    this.populateFields(card, expert);\n    \n    // Handle repeating elements (projects, social links)\n    this.populateRepeatingElements(card, expert);\n    \n    // Handle conditional display\n    this.handleConditionalDisplay(card, expert);\n\n    return card;\n  }\n\n  /**\n   * Populate data fields in the card\n   */\n  private populateFields(card: Element, expert: ExpertProfile): void {\n    const fieldElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.field}]`);\n    \n    fieldElements.forEach(element => {\n      const fieldName = this.getAttr(element, ATTRS.field) as ExpertField;\n      const format = this.getAttr(element, ATTRS.format);\n      \n      if (!fieldName || !(fieldName in expert)) return;\n\n      const value = expert[fieldName];\n      this.setElementValue(element, value, format);\n    });\n\n    // Handle star ratings\n    const starsElements = this.querySelectorAll(card, '[data-contra-stars]');\n    starsElements.forEach(element => {\n      if (expert.averageReviewScore) {\n        element.innerHTML = utils.renderStars(expert.averageReviewScore);\n      }\n    });\n  }\n\n  /**\n   * Set element value with proper formatting\n   */\n  private setElementValue(element: Element, value: any, format?: string | null): void {\n    if (value == null) return;\n\n    if (element instanceof HTMLImageElement) {\n      element.src = String(value);\n      element.alt = element.alt || 'Image';\n    } else if (element instanceof HTMLAnchorElement) {\n      element.href = String(value);\n      if (!element.textContent?.trim()) {\n        element.textContent = String(value);\n      }\n    } else if (element instanceof HTMLInputElement) {\n      element.value = String(value);\n    } else {\n      // Text content with formatting\n      let displayValue = String(value);\n      \n      if (format) {\n        switch (format) {\n          case 'currency':\n            displayValue = typeof value === 'number' ? `$${value}` : displayValue;\n            break;\n          case 'rate':\n            displayValue = utils.formatRate(typeof value === 'number' ? value : null);\n            break;\n          case 'number':\n            displayValue = typeof value === 'number' ? value.toLocaleString() : displayValue;\n            break;\n          case 'truncate':\n            displayValue = displayValue.length > 100 ? displayValue.substring(0, 97) + '...' : displayValue;\n            break;\n        }\n      }\n      \n      element.textContent = displayValue;\n    }\n  }\n\n  /**\n   * Handle repeating elements (projects, social links)\n   */\n  private populateRepeatingElements(card: Element, expert: ExpertProfile): void {\n    const repeatElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.repeat}]`);\n    \n    repeatElements.forEach(container => {\n      const repeatType = this.getAttr(container, ATTRS.repeat);\n      const maxItems = parseInt(this.getAttr(container, ATTRS.max) || '10');\n      \n      if (repeatType === 'projects' && expert.projects) {\n        this.populateRepeatingContainer(container, expert.projects.slice(0, maxItems));\n      } else if (repeatType === 'socialLinks' && expert.socialLinks) {\n        this.populateRepeatingContainer(container, expert.socialLinks.slice(0, maxItems));\n      } else if (repeatType === 'skillTags' && expert.skillTags) {\n        this.populateRepeatingContainer(container, expert.skillTags.slice(0, maxItems).map((tag: string) => ({ name: tag })));\n      }\n    });\n  }\n\n  /**\n   * Populate a repeating container with items\n   */\n  private populateRepeatingContainer(container: Element, items: any[]): void {\n    const template = container.firstElementChild;\n    if (!template) return;\n\n    // Clear existing items\n    container.innerHTML = '';\n    \n    // Create items from template\n    items.forEach(item => {\n      const itemElement = template.cloneNode(true) as Element;\n      this.populateFields(itemElement, item);\n      container.appendChild(itemElement);\n    });\n    \n    // Hide container if no items\n    if (items.length === 0) {\n      (container as HTMLElement).style.display = 'none';\n    }\n  }\n\n  /**\n   * Handle conditional display based on data\n   */\n  private handleConditionalDisplay(card: Element, expert: ExpertProfile): void {\n    const conditionalElements = this.querySelectorAll(card, `[${ATTR_PREFIX}${ATTRS.showWhen}], [${ATTR_PREFIX}${ATTRS.hideWhen}]`);\n    \n    conditionalElements.forEach(element => {\n      const showWhen = this.getAttr(element, ATTRS.showWhen);\n      const hideWhen = this.getAttr(element, ATTRS.hideWhen);\n      \n      let shouldShow = true;\n      \n      if (showWhen) {\n        shouldShow = this.evaluateCondition(expert, showWhen);\n      }\n      \n      if (hideWhen) {\n        shouldShow = shouldShow && !this.evaluateCondition(expert, hideWhen);\n      }\n      \n      (element as HTMLElement).style.display = shouldShow ? '' : 'none';\n    });\n  }\n\n  /**\n   * Evaluate a condition against expert data\n   */\n  private evaluateCondition(expert: ExpertProfile, condition: string): boolean {\n    // Simple condition evaluation (can be extended)\n    // Format: \"field:value\" or \"field:>value\" or \"field:<value\"\n    const [field, operator, value] = condition.split(':');\n    const expertValue = (expert as any)[field];\n    \n    if (expertValue == null) return false;\n    \n    switch (operator) {\n      case '>':\n        return Number(expertValue) > Number(value);\n      case '<':\n        return Number(expertValue) < Number(value);\n      case '>=':\n        return Number(expertValue) >= Number(value);\n      case '<=':\n        return Number(expertValue) <= Number(value);\n      default:\n        return String(expertValue).toLowerCase() === value.toLowerCase();\n    }\n  }\n\n  /**\n   * Update UI states based on current data\n   */\n  private updateUIStates(container: Element, programId: string): void {\n    const state = this.state.getState(programId);\n    \n    // Show/hide empty state\n    const emptyElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.empty}]`);\n    if (emptyElement) {\n      (emptyElement as HTMLElement).style.display = state.experts.length === 0 ? '' : 'none';\n    }\n    \n    // Update pagination info\n    const paginationElements = this.querySelectorAll(container, '[data-contra-pagination-info]');\n    paginationElements.forEach(element => {\n      const { currentPage, totalCount } = state;\n      const pageSize = state.filters.limit || 20;\n      const totalPages = Math.ceil(totalCount / pageSize);\n      \n      element.textContent = `Page ${currentPage} of ${totalPages} (${totalCount} total)`;\n    });\n    \n    // Update filter summaries\n    const filterSummaries = this.querySelectorAll(container, '[data-contra-filter-summary]');\n    filterSummaries.forEach(element => {\n      const activeFilters = Object.entries(state.filters)\n        .filter(([_key, value]) => value != null && value !== '')\n        .map(([key, value]) => `${key}: ${value}`)\n        .join(', ');\n      \n      element.textContent = activeFilters || 'No filters applied';\n    });\n  }\n\n  // ... (utility methods continue below)\n\n  /**\n   * Utility Methods\n   */\n  private getAttr(element: Element, name: string): string | null {\n    return element.getAttribute(`${ATTR_PREFIX}${name}`);\n  }\n\n  private querySelector(element: Element, selector: string): Element | null {\n    return element.querySelector(selector);\n  }\n\n  private querySelectorAll(element: Element, selector: string): Element[] {\n    return Array.from(element.querySelectorAll(selector));\n  }\n\n  private findExpertContainers(): Element[] {\n    return Array.from(document.querySelectorAll(`[${ATTR_PREFIX}${ATTRS.program}]`));\n  }\n\n  private parseFiltersFromElement(element: Element): ExpertFilters {\n    const filters: ExpertFilters = {};\n    \n    // Parse filter attributes\n    const filterMap = {\n      'available': 'available',\n      'languages': 'languages', \n      'location': 'location',\n      'min-rate': 'minRate',\n      'max-rate': 'maxRate',\n      'sort': 'sortBy',\n      'limit': 'limit',\n      'offset': 'offset'\n    };\n\n    Object.entries(filterMap).forEach(([attr, filterKey]) => {\n      const value = this.getAttr(element, attr);\n      if (value != null) {\n        if (filterKey === 'available') {\n          (filters as any)[filterKey] = value === 'true';\n        } else if (filterKey === 'languages') {\n          (filters as any)[filterKey] = value.split(',').map(v => v.trim());\n        } else if (['minRate', 'maxRate', 'limit', 'offset'].includes(filterKey)) {\n          (filters as any)[filterKey] = parseInt(value);\n        } else {\n          (filters as any)[filterKey] = value;\n        }\n      }\n    });\n\n    return filters;\n  }\n\n  private getControlValue(control: HTMLInputElement | HTMLSelectElement): any {\n    if (control instanceof HTMLInputElement) {\n      switch (control.type) {\n        case 'checkbox':\n          return control.checked;\n        case 'number':\n        case 'range':\n          return control.valueAsNumber;\n        default:\n          return control.value;\n      }\n    } else if (control instanceof HTMLSelectElement) {\n      if (control.multiple) {\n        return Array.from(control.selectedOptions).map(option => option.value);\n      }\n      return control.value;\n    }\n    return null;\n  }\n\n  private updateFilter(programId: string, filterKey: string, value: any, type: string = 'replace'): void {\n    const state = this.state.getState(programId);\n    const newFilters = { ...state.filters };\n\n    if (type === 'append' && Array.isArray(newFilters[filterKey as keyof ExpertFilters])) {\n      const currentArray = newFilters[filterKey as keyof ExpertFilters] as any[];\n      newFilters[filterKey as keyof ExpertFilters] = [...currentArray, value] as any;\n    } else {\n      (newFilters as any)[filterKey] = value;\n    }\n\n    this.state.updateState(programId, { filters: newFilters });\n    \n    // Dispatch filter change event\n    const event: FilterChangeEvent = {\n      filters: newFilters,\n      element: document.querySelector(`[data-program-id=\"${programId}\"]`) as HTMLElement\n    };\n    \n    this.dispatchEvent(document as any, 'filterChange', event);\n  }\n\n  private handleAction(programId: string, action: string, _target?: string | null, _button?: Element): void {\n    const state = this.state.getState(programId);\n    \n    switch (action) {\n      case 'next-page':\n        this.updateFilter(programId, 'offset', (state.filters.offset || 0) + (state.filters.limit || 20));\n        break;\n      case 'prev-page':\n        this.updateFilter(programId, 'offset', Math.max(0, (state.filters.offset || 0) - (state.filters.limit || 20)));\n        break;\n      case 'clear-filters':\n        this.state.updateState(programId, { filters: {} });\n        break;\n      case 'reload':\n        this.client.clearCache(`experts:${programId}`);\n        break;\n    }\n    \n    if (this.config.autoReload) {\n      this.debouncedReload.get(programId)?.();\n    }\n  }\n\n  private showLoading(container: Element, show: boolean): void {\n    const loadingElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.loading}]`);\n    if (loadingElement) {\n      (loadingElement as HTMLElement).style.display = show ? '' : 'none';\n    }\n    \n    (container as HTMLElement).classList.toggle(this.config.loadingClass, show);\n  }\n\n  private showError(container: Element, error: Error): void {\n    const errorElement = this.querySelector(container, `[${ATTR_PREFIX}${ATTRS.error}]`);\n    if (errorElement) {\n      errorElement.textContent = error.message;\n      (errorElement as HTMLElement).style.display = '';\n    }\n    \n    (container as HTMLElement).classList.add(this.config.errorClass);\n    this.log('Error displayed', error);\n  }\n\n  private dispatchEvent(target: Element | Document, eventName: string, detail: any): void {\n    const event = new CustomEvent(`contra:${eventName}`, { detail });\n    target.dispatchEvent(event);\n  }\n\n  private log(message: string, ...args: any[]): void {\n    if (this.config.debug) {\n      console.log(`[ContraWebflow] ${message}`, ...args);\n    }\n  }\n}\n\n/**\n * Auto-initialize runtime when DOM is ready\n */\nfunction autoInit(): void {\n  const configElement = document.getElementById('contra-config');\n  if (!configElement) {\n    console.warn('[ContraWebflow] No config element found. Runtime not initialized.');\n    return;\n  }\n\n  try {\n    const config = JSON.parse(configElement.textContent || '{}');\n    const runtime = new ContraWebflowRuntime(config);\n    \n    // Expose runtime globally for debugging\n    (window as any).contraRuntime = runtime;\n    \n    runtime.init().catch(error => {\n      console.error('[ContraWebflow] Runtime initialization failed:', error);\n    });\n    \n  } catch (error) {\n    console.error('[ContraWebflow] Failed to parse config:', error);\n  }\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', autoInit);\n} else {\n  autoInit();\n}\n\n// Export runtime class for manual initialization\nexport { ContraWebflowRuntime as default }; ","import type {\n  ClientConfig,\n  ExpertProfile,\n  ExpertFilters,\n  ProgramSummary,\n  ListResponse,\n  ApiResponse,\n  ErrorResponse,\n  Filter,\n  FilterListResponse\n} from '@contra/types';\n\n/**\n * Professional Contra API Client\n * Features: Caching, retry logic, error handling, request deduplication\n */\nexport class ContraClient {\n  private config: Required<ClientConfig>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n  private pendingRequests = new Map<string, Promise<any>>();\n  \n  // Cache TTL settings (in milliseconds)\n  private static readonly CACHE_TTL = {\n    experts: 5 * 60 * 1000,      // 5 minutes for expert lists\n    expert: 10 * 60 * 1000,     // 10 minutes for individual experts\n    program: 30 * 60 * 1000,    // 30 minutes for program info\n    filters: 60 * 60 * 1000,    // 1 hour for available filters\n  };\n\n  constructor(config: ClientConfig) {\n    this.config = {\n      baseUrl: 'https://contra.com',\n      timeout: 10000,\n      debug: false,\n      ...config,\n    };\n\n    if (this.config.debug) {\n      console.log('[ContraClient] Initialized with config:', this.config);\n    }\n  }\n\n  /**\n   * Core fetch method with retry logic and error handling\n   */\n  private async fetch<T>(\n    endpoint: string,\n    options: RequestInit = {},\n    retries = 3\n  ): Promise<T> {\n    const url = `${this.config.baseUrl}${endpoint}`;\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);\n\n    const requestOptions: RequestInit = {\n      ...options,\n      signal: controller.signal,\n      headers: {\n        'Accept': 'application/json',\n        'X-API-Key': this.config.apiKey,\n        ...options.headers,\n      },\n    };\n\n    try {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Fetching: ${url}`, requestOptions);\n      }\n\n      const response = await fetch(url, requestOptions);\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        // Try to parse error response\n        let errorData: ErrorResponse;\n        try {\n          errorData = await response.json();\n        } catch {\n          errorData = {\n            code: `HTTP_${response.status}`,\n            message: response.statusText || 'Unknown error'\n          };\n        }\n\n        // Retry on 5xx errors or rate limits\n        if ((response.status >= 500 || response.status === 429) && retries > 0) {\n          const delay = Math.pow(2, 3 - retries) * 1000; // Exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n          return this.fetch<T>(endpoint, options, retries - 1);\n        }\n\n        throw new ContraAPIError(errorData.message, errorData.code, response.status);\n      }\n\n      const data = await response.json();\n      \n      if (this.config.debug) {\n        console.log(`[ContraClient] Response:`, data);\n      }\n\n      return data;\n\n    } catch (error) {\n      clearTimeout(timeoutId);\n      \n      if (error instanceof ContraAPIError) {\n        throw error;\n      }\n\n      if (error instanceof Error && error.name === 'AbortError') {\n        throw new ContraAPIError(`Request timeout after ${this.config.timeout}ms`, 'TIMEOUT');\n      }\n\n      // Network or other errors - retry if we have retries left\n      if (retries > 0) {\n        const delay = Math.pow(2, 3 - retries) * 1000;\n        await new Promise(resolve => setTimeout(resolve, delay));\n        return this.fetch<T>(endpoint, options, retries - 1);\n      }\n\n      throw new ContraAPIError(\n        error instanceof Error ? error.message : 'Unknown error',\n        'NETWORK_ERROR'\n      );\n    }\n  }\n\n  /**\n   * Get from cache or fetch with request deduplication\n   */\n  private async fetchWithCache<T>(\n    cacheKey: string,\n    endpoint: string,\n    ttl: number,\n    options?: RequestInit\n  ): Promise<T> {\n    // Check cache first\n    const cached = this.cache.get(cacheKey);\n    if (cached && Date.now() - cached.timestamp < cached.ttl) {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Cache hit: ${cacheKey}`);\n      }\n      return cached.data;\n    }\n\n    // Check for pending request (deduplication)\n    const pendingKey = `${endpoint}${JSON.stringify(options)}`;\n    if (this.pendingRequests.has(pendingKey)) {\n      if (this.config.debug) {\n        console.log(`[ContraClient] Request deduplication: ${pendingKey}`);\n      }\n      return this.pendingRequests.get(pendingKey)!;\n    }\n\n    // Make the request\n    const requestPromise = this.fetch<T>(endpoint, options);\n    this.pendingRequests.set(pendingKey, requestPromise);\n\n    try {\n      const data = await requestPromise;\n      \n      // Cache the result\n      this.cache.set(cacheKey, {\n        data,\n        timestamp: Date.now(),\n        ttl\n      });\n\n      return data;\n    } finally {\n      this.pendingRequests.delete(pendingKey);\n    }\n  }\n\n  /**\n   * Build query string from filters\n   */\n  private buildQueryString(filters: ExpertFilters): string {\n    const params = new URLSearchParams();\n    \n    Object.entries(filters).forEach(([key, value]) => {\n      if (value != null && value !== '') {\n        if (Array.isArray(value)) {\n          params.set(key, value.join(','));\n        } else {\n          params.set(key, String(value));\n        }\n      }\n    });\n\n    const queryString = params.toString();\n    return queryString ? `?${queryString}` : '';\n  }\n\n  /**\n   * Get program information\n   */\n  async getProgram(programNid: string): Promise<ProgramSummary> {\n    const cacheKey = `program:${programNid}`;\n    const endpoint = `/public-api/programs/${programNid}`;\n    \n    const response = await this.fetchWithCache<ApiResponse<ProgramSummary>>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.program\n    );\n    \n    return response.data;\n  }\n\n  /**\n   * List experts with advanced filtering and caching\n   */\n  async listExperts(\n    programNid: string,\n    filters: ExpertFilters = {}\n  ): Promise<ListResponse<ExpertProfile>> {\n    const queryString = this.buildQueryString(filters);\n    const cacheKey = `experts:${programNid}:${JSON.stringify(filters)}`;\n    const endpoint = `/public-api/programs/${programNid}/experts${queryString}`;\n    \n    return this.fetchWithCache<ListResponse<ExpertProfile>>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.experts\n    );\n  }\n\n  /**\n   * Search experts (using the main experts endpoint with filters)\n   */\n  async searchExperts(\n    programNid: string,\n    query: string,\n    filters: ExpertFilters = {}\n  ): Promise<ListResponse<ExpertProfile>> {\n    // Search is handled by client-side filtering since API doesn't support text search\n    const experts = await this.listExperts(programNid, filters);\n    \n    // Client-side filtering for search (since API doesn't support text search)\n    if (query.trim()) {\n      const searchTerm = query.toLowerCase();\n      experts.data = experts.data.filter(expert => \n        expert.name.toLowerCase().includes(searchTerm) ||\n        expert.oneLiner.toLowerCase().includes(searchTerm) ||\n        expert.skillTags.some(tag => tag.toLowerCase().includes(searchTerm))\n      );\n    }\n    \n    return experts;\n  }\n\n  /**\n   * Get available filter options for a program\n   */\n  async getFilterOptions(programNid: string): Promise<FilterListResponse> {\n    const cacheKey = `filters:${programNid}`;\n    const endpoint = `/public-api/programs/${programNid}/filters`;\n    \n    return this.fetchWithCache<FilterListResponse>(\n      cacheKey,\n      endpoint,\n      ContraClient.CACHE_TTL.filters\n    );\n  }\n\n  /**\n   * Clear cache (useful for forced refreshes)\n   */\n  clearCache(pattern?: string): void {\n    if (pattern) {\n      // Clear specific cache entries\n      for (const key of this.cache.keys()) {\n        if (key.includes(pattern)) {\n          this.cache.delete(key);\n        }\n      }\n    } else {\n      // Clear all cache\n      this.cache.clear();\n    }\n\n    if (this.config.debug) {\n      console.log(`[ContraClient] Cache cleared${pattern ? ` (pattern: ${pattern})` : ''}`);\n    }\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getCacheStats(): {\n    size: number;\n    entries: Array<{ key: string; age: number; ttl: number }>;\n  } {\n    const now = Date.now();\n    const entries = Array.from(this.cache.entries()).map(([key, value]) => ({\n      key,\n      age: now - value.timestamp,\n      ttl: value.ttl\n    }));\n\n    return {\n      size: this.cache.size,\n      entries\n    };\n  }\n}\n\n/**\n * Custom error class for API errors\n */\nexport class ContraAPIError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public status?: number\n  ) {\n    super(message);\n    this.name = 'ContraAPIError';\n  }\n}\n\n/**\n * Utility functions\n */\nexport const utils = {\n  /**\n   * Format hourly rate with proper handling of null values\n   */\n  formatRate(rate: number | null): string {\n    return rate ? `$${rate}/hr` : 'Rate on request';\n  },\n\n  /**\n   * Generate star rating HTML\n   */\n  renderStars(rating: number): string {\n    const fullStars = Math.floor(rating);\n    const hasHalfStar = (rating % 1) >= 0.5;\n    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);\n    \n    let html = '';\n    \n    // Full stars\n    for (let i = 0; i < fullStars; i++) {\n      html += `<svg class=\"star star-full\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"#FFD700\">\n        <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    // Half star\n    if (hasHalfStar) {\n      html += `<svg class=\"star star-half\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\n        <defs>\n          <linearGradient id=\"half-${rating}\">\n            <stop offset=\"50%\" stop-color=\"#FFD700\"/>\n            <stop offset=\"50%\" stop-color=\"#E5E5E5\"/>\n          </linearGradient>\n        </defs>\n        <path fill=\"url(#half-${rating})\" d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    // Empty stars\n    for (let i = 0; i < emptyStars; i++) {\n      html += `<svg class=\"star star-empty\" width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"#E5E5E5\">\n        <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z\"/>\n      </svg>`;\n    }\n    \n    return html;\n  },\n\n  /**\n   * Debounce function for search inputs\n   */\n  debounce<T extends (...args: any[]) => any>(\n    func: T,\n    wait: number\n  ): (...args: Parameters<T>) => void {\n    let timeout: NodeJS.Timeout;\n    return (...args: Parameters<T>) => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => func(...args), wait);\n    };\n  },\n\n  /**\n   * Throttle function for scroll events\n   */\n  throttle<T extends (...args: any[]) => any>(\n    func: T,\n    limit: number\n  ): (...args: Parameters<T>) => void {\n    let inThrottle: boolean;\n    return (...args: Parameters<T>) => {\n      if (!inThrottle) {\n        func(...args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n}; "],"mappings":"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","names":["runtime_exports","__export","ContraWebflowRuntime","_ContraClient","config","endpoint","options","retries","url","controller","timeoutId","requestOptions","response","errorData","delay","resolve","ContraAPIError","data","error","cacheKey","ttl","cached","pendingKey","requestPromise","filters","params","key","value","queryString","programNid","query","experts","searchTerm","expert","tag","pattern","now","entries","ContraClient","message","code","status","utils","rate","rating","fullStars","hasHalfStar","emptyStars","html","i","func","wait","timeout","args","limit","inThrottle","ATTR_PREFIX","ATTRS","RuntimeState","programId","updates","state","ContraWebflowRuntime","config","f","containers","container","error","element","initialFilters","debouncedReload","d","filterControls","control","filterKey","filterType","eventType","button","action","target","e","response","experts","template","card","expert","expertCard","fieldName","format","value","displayValue","repeatType","maxItems","tag","items","item","itemElement","showWhen","hideWhen","shouldShow","condition","field","operator","expertValue","emptyElement","currentPage","totalCount","pageSize","totalPages","activeFilters","_key","key","name","selector","filters","attr","v","option","type","newFilters","currentArray","event","_target","_button","show","loadingElement","errorElement","eventName","detail","message","args","autoInit","configElement","runtime"]}